---
import BaseLayout from '../layouts/BaseLayout.astro';
import PageHero from '../components/PageHero.astro';
---

<BaseLayout 
  title="Research & Methodology - Instrumetriq"
  description="How Instrumetriq collects and scores public X (Twitter) posts and aggregates signals into time windows."
>
  <PageHero
    eyebrow="RESEARCH"
    title="Research & Methodology"
    subtitle="How we collect and summarize sentiment signals, with ethics, privacy, and documentation as first principles."
  />
  <div class="pageContent">
    <!-- Section 1: Header -->
    <section>
      <h2>Overview</h2>
      <p>
        Instrumetriq observes short-lived market narratives by combining high-resolution market microstructure with aggregated social sentiment.
      </p>
      <p>
        Each asset is monitored ~120–130 minutes; spot price sampled every 10 seconds.
      </p>
      <p>
        This is an observational dataset: we publish measurements and derived statistics, not trading advice.
      </p>
    </section>

    <!-- Section 2: Hybrid Sentiment -->
    <section>
      <h2>How scoring works</h2>
      
      <h3>Data pipeline</h3>
      <ul>
        <li>Posts are collected for each asset via controlled queries.</li>
        <li>Posts are deduplicated.</li>
        <li>Each post is scored by TWO AI models (primary + referee).</li>
        <li>Referee confidence controls when we accept, override, or label neutral.</li>
        <li>Cycle-level aggregates are written (pos/neu/neg ratios, mean score, confidence stats).</li>
        <li>Silence handling is explicit (recent_posts_count, is_silent, hours_since_latest_tweet).</li>
      </ul>

      <h3>Hybrid decisions</h3>
      <div class="decision-legend">
        <div class="decision-item">
          <strong>primary_default</strong>
          <span>Primary model decision accepted</span>
        </div>
        <div class="decision-item">
          <strong>referee_override</strong>
          <span>Referee overrides primary</span>
        </div>
        <div class="decision-item">
          <strong>referee_neutral_band</strong>
          <span>Forced neutral due to uncertainty band</span>
        </div>
      </div>
      <p class="legend-note">
        These decision sources are tracked per cycle in hybrid_decision_stats.decision_sources.
      </p>
    </section>

    <!-- Section 3: What we store per entry -->
    <section>
      <h2>What we store per entry</h2>
      <div class="storage-grid">
        <div class="storage-card">
          <h3>Market microstructure</h3>
          <p>Spread, depth at multiple bps, order book imbalance, taker ratios.</p>
        </div>
        
        <div class="storage-card">
          <h3>Liquidity quality</h3>
          <p>liq_qv_usd plus global/self percentiles for regime comparisons.</p>
        </div>
        
        <div class="storage-card">
          <h3>Sentiment windows (aggregated)</h3>
          <p>last_cycle and last_2_cycles aggregates (not raw tweets), including author_stats and engagement.</p>
        </div>
        
        <div class="storage-card">
          <h3>Outcomes & derived features</h3>
          <p>Price-path metrics and derived entry statistics computed from the recorded series.</p>
        </div>
        
        <div class="storage-card">
          <h3>Activity & silence context</h3>
          <p>Explicit tracking of posting activity and silence states to distinguish absence of signal from neutral sentiment, including time since latest observed post.</p>
        </div>
        
        <div class="storage-card">
          <h3>Author & engagement aggregates</h3>
          <p>Aggregated author statistics and engagement signals (e.g. follower counts, verification flags, likes, replies, reposts). Author identities are not stored or exposed.</p>
        </div>
      </div>
    </section>

    <!-- Section 4: Entry Deep Dive -->
    <!-- deep-dive-v2: 2026-01-12 -->
    <section class="deep-dive deep-dive-v2">
      <h2>Entry Deep Dive (sample)</h2>
      <p class="deep-dive-subtitle">
        A rotating example from the public sample archive, illustrating how one monitored entry is represented end-to-end.
      </p>

      <div id="deepDiveContainer" 
           data-json="/data/sample_entries_v7.json"
           data-spots="/data/sample_entries_spots_v7.json">
        <div class="loading-state">Loading sample entry...</div>
      </div>
    </section>
  </div>
</BaseLayout>

<style is:global>
  section {
    margin-bottom: var(--space-8);
  }

  h2 {
    font-size: var(--font-size-2xl);
    margin-bottom: var(--space-4);
    color: var(--text);
  }

  h3 {
    font-size: var(--font-size-xl);
    margin-top: var(--space-5);
    margin-bottom: var(--space-3);
    color: var(--text);
  }

  p {
    line-height: 1.6;
    color: var(--text-muted);
    margin-bottom: var(--space-3);
  }

  ul {
    line-height: 1.7;
    color: var(--text-muted);
    margin: var(--space-3) 0;
    padding-left: var(--space-5);
  }

  li {
    margin-bottom: var(--space-2);
  }

  /* Hybrid decisions legend */
  .decision-legend {
    display: flex;
    flex-direction: column;
    gap: var(--space-3);
    margin: var(--space-4) 0;
    padding: var(--space-4);
    background-color: var(--panel2);
    border-radius: 4px;
  }

  .decision-item {
    display: flex;
    flex-direction: column;
    gap: var(--space-1);
  }

  .decision-item strong {
    color: var(--accent);
    font-size: 0.9375rem;
    font-family: monospace;
  }

  .decision-item span {
    color: var(--text-muted);
    font-size: 0.875rem;
  }

  .legend-note {
    font-size: 0.875rem;
    color: var(--text-dim);
    font-style: italic;
    margin-top: var(--space-2);
  }

  /* Storage cards grid */
  .storage-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: var(--space-4);
    margin-top: var(--space-4);
  }

  .storage-card {
    padding: var(--space-4);
    background-color: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 4px;
    transition: border-color var(--transition-base);
  }

  .storage-card:hover {
    border-color: var(--border2);
  }

  .storage-card h3 {
    font-size: 1.125rem;
    margin: 0 0 var(--space-2) 0;
    color: var(--text);
  }

  .storage-card p {
    font-size: 0.9375rem;
    line-height: 1.5;
    margin: 0;
    color: var(--text-muted);
  }

  @media (max-width: 768px) {
    .storage-grid {
      grid-template-columns: 1fr;
    }
  }

  /* Deep Dive Section */
  .deep-dive-subtitle {
    font-size: 0.9375rem;
    color: var(--text-muted);
    font-style: italic;
    margin-bottom: var(--space-5);
  }

  /* Deep dive navigation */
  .deep-dive-nav {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--space-4);
    padding: var(--space-4);
    background-color: var(--bg);
    border-bottom: 1px solid var(--border);
    margin-bottom: var(--space-6);
  }

  .deep-dive-nav .nav-info {
    flex: 1;
    text-align: center;
  }

  .deep-dive-nav .nav-info .symbol-title {
    font-size: 1.75rem;
    font-weight: 600;
    color: var(--text);
    display: block;
    margin-bottom: var(--space-1);
  }

  .deep-dive-nav .nav-counter {
    font-size: 0.875rem;
    color: var(--text-muted);
  }

  /* Deep Dive V2 - New Layout */
  .deep-dive-v2 .deep-dive-header-v2 {
    background-color: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: var(--space-5);
    margin-bottom: var(--space-6);
  }

  .deep-dive-v2 .deep-dive-header-row {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    gap: 16px;
    margin-bottom: var(--space-3);
  }

  .deep-dive-v2 .deep-dive-symbol {
    font-family: inherit;
    font-size: 32px;
    font-weight: 700;
    color: var(--text);
    letter-spacing: 0.2px;
  }

  .deep-dive-v2 .deep-dive-index {
    opacity: 0.7;
    font-size: 14px;
    color: var(--text-muted);
    white-space: nowrap;
  }

  .deep-dive-v2 .deep-dive-nav-row {
    display: flex;
    gap: 12px;
    margin-top: 10px;
  }

  .deep-dive-v2 .deep-dive-btn {
    padding: 10px 14px;
    border-radius: 12px;
    border: 1px solid var(--border);
    background: rgba(255, 255, 255, 0.02);
    color: var(--text);
    font-size: 0.9375rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
  }

  .deep-dive-v2 .deep-dive-btn:hover {
    border-color: var(--accent);
    background: rgba(0, 188, 212, 0.1);
  }

  .deep-dive-v2 .deep-dive-btn:focus {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
  }

  @media (max-width: 768px) {
    .deep-dive-v2 .deep-dive-header-row {
      flex-direction: column;
      align-items: flex-start;
    }
    
    .deep-dive-v2 .deep-dive-nav-row {
      width: 100%;
    }
    
    .deep-dive-v2 .deep-dive-btn {
      flex: 1;
    }
  }

  .nav-btn {
    padding: var(--space-3) var(--space-5);
    background-color: var(--panel);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
    font-size: 0.9375rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
    display: inline-flex;
    align-items: center;
    gap: var(--space-2);
  }

  .nav-btn:hover {
    background-color: var(--accent);
    border-color: var(--accent);
    color: var(--bg);
    box-shadow: 0 2px 8px rgba(0, 188, 212, 0.3);
  }

  .nav-btn:active {
    transform: translateY(1px);
  }

  .nav-btn:focus {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
  }

  @media (max-width: 768px) {
    .deep-dive-nav {
      flex-direction: column;
      gap: var(--space-3);
    }

    .deep-dive-nav .nav-info {
      order: -1;
      width: 100%;
    }

    .nav-btn {
      width: 100%;
      justify-content: center;
    }
  }

  /* Context and Metrics grid */
  .context-metrics-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-6);
    margin-bottom: var(--space-6);
  }

  .deep-dive-v2 .deep-dive-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 28px;
    align-items: start;
    margin-bottom: var(--space-6);
  }

  @media (max-width: 768px) {
    .context-metrics-grid {
      grid-template-columns: 1fr;
      gap: var(--space-5);
    }
    
    .deep-dive-v2 .deep-dive-grid {
      grid-template-columns: 1fr;
      gap: var(--space-5);
    }
  }

  .context-section,
  .metrics-section {
    background-color: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: var(--space-4);
  }

  .context-section h3,
  .metrics-section h3 {
    font-size: 1.125rem;
    font-weight: 600;
    margin-bottom: var(--space-4);
    color: var(--text);
    border-bottom: 1px solid var(--border);
    padding-bottom: var(--space-2);
  }

  .context-grid {
    display: table;
    width: 100%;
    border-collapse: collapse;
  }

  .context-item {
    display: table-row;
  }

  .context-label,
  .context-value {
    display: table-cell;
    padding: 12px 8px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    line-height: 1.4;
  }

  .context-item:last-child .context-label,
  .context-item:last-child .context-value {
    border-bottom: none;
  }

  .context-label {
    font-size: 0.875rem;
    color: var(--text-muted);
    font-weight: 400;
    padding-right: var(--space-4);
    width: 70%;
  }

  .context-value {
    font-size: 0.9375rem;
    color: var(--text);
    font-weight: 600;
    text-align: right;
    white-space: nowrap;
  }

  .loading-state {
    padding: var(--space-6);
    text-align: center;
    color: var(--text-muted);
  }

  .error-state {
    padding: var(--space-6);
    text-align: center;
    color: #ef4444;
  }

  .deep-dive-content {
    display: flex;
    flex-direction: column;
    gap: var(--space-6);
  }

  /* Context Badges */
  .context-badges {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-2);
    margin-bottom: var(--space-4);
  }

  .context-badge {
    padding: var(--space-2) var(--space-3);
    background-color: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 4px;
    font-size: 0.875rem;
    color: var(--text-muted);
  }

  .context-badge strong {
    color: var(--text);
    margin-right: var(--space-1);
  }

  /* Charts */
  .chart-container {
    margin-bottom: var(--space-6);
    width: 100%;
  }

  .chart-wrapper {
    margin-bottom: var(--space-6);
    width: 100%;
    max-width: 100%;
  }

  .chart-title {
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--text);
    margin-bottom: var(--space-3);
  }

  .chart-panel {
    width: 100%;
    max-width: 100%;
    padding: 18px;
    border: 1px solid var(--border);
    border-radius: 16px;
    background: rgba(255, 255, 255, 0.02);
    position: relative;
  }

  .chart-panel canvas {
    display: block;
  }

  .chart-tooltip {
    position: absolute;
    background: #111;
    border: 1px solid var(--accent);
    padding: 8px 10px;
    border-radius: 10px;
    font-size: 12px;
    color: var(--text);
    pointer-events: none;
    white-space: nowrap;
    z-index: 10;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  }

  .chart-canvas {
    width: 100%;
    height: 400px;
    min-height: 350px;
    background-color: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 6px;
    display: block;
  }

  @media (max-width: 768px) {
    .chart-canvas {
      height: 320px;
      min-height: 280px;
    }
  }

  .chart-caption {
    margin-top: var(--space-2);
    font-size: 0.8125rem;
    color: var(--text-dim);
    font-style: italic;
  }

  /* Metrics Table */
  .metrics-table {
    width: 100%;
    border-collapse: collapse;
  }

  .metrics-table td {
    padding: 12px 8px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    line-height: 1.4;
  }

  .metrics-table tr:last-child td {
    border-bottom: none;
  }

  .metrics-table .metrics-label {
    color: var(--text-muted);
    font-size: 0.875rem;
    font-weight: 400;
    padding-right: var(--space-4);
    width: 70%;
  }

  .metrics-table .metrics-value {
    text-align: right;
    font-family: monospace;
    color: var(--text);
    font-size: 0.9375rem;
    font-weight: 600;
    white-space: nowrap;
  }
</style>

<script>
  // Entry Deep Dive - Client-side rendering with navigation
  import { extractPricePath, extractSentimentPath, calculateMetrics, formatMetric, type PricePoint, type SentimentPoint } from '../lib/deriveEntryMetrics';

  let allEntries: any[] = [];
  let spotPricesMap: Map<string, any[]> = new Map();
  let sentimentTimeseriesMap: Map<string, any[]> = new Map();
  let currentIndex = 0;

  document.addEventListener('DOMContentLoaded', async () => {
    const container = document.getElementById('deepDiveContainer');
    if (!container) return;

    const jsonUrl = container.getAttribute('data-json');
    const spotsUrl = container.getAttribute('data-spots');
    const timeseriesUrl = '/data/sample_symbols_sentiment_timeseries.json';
    
    if (!jsonUrl || !spotsUrl) {
      container.innerHTML = '<div class="error-state">Configuration error: missing data URL</div>';
      return;
    }

    try {
      // Fetch entries, spot prices, and sentiment timeseries
      const [entriesResponse, spotsResponse, timeseriesResponse] = await Promise.all([
        fetch(jsonUrl),
        fetch(spotsUrl),
        fetch(timeseriesUrl)
      ]);

      if (!entriesResponse.ok || !spotsResponse.ok) {
        throw new Error('Failed to load data');
      }

      const entriesData = await entriesResponse.json();
      const spotsData = await spotsResponse.json();
      
      allEntries = entriesData.entries || [];
      const spots = spotsData.spots || [];

      if (allEntries.length === 0) {
        container.innerHTML = '<div class="error-state">No entries available</div>';
        return;
      }

      // Build spot prices lookup by symbol
      spots.forEach((spot: any) => {
        if (spot.symbol && spot.spot_prices) {
          spotPricesMap.set(spot.symbol, spot.spot_prices);
        }
      });

      // Load sentiment timeseries if available
      if (timeseriesResponse.ok) {
        const timeseriesData = await timeseriesResponse.json();
        const seriesBySymbol = timeseriesData.series_by_symbol || {};
        Object.keys(seriesBySymbol).forEach(symbol => {
          sentimentTimeseriesMap.set(symbol, seriesBySymbol[symbol]);
        });
        console.log(`[INFO] Loaded sentiment timeseries for ${sentimentTimeseriesMap.size} symbols`);
      } else {
        console.warn('[WARN] Sentiment timeseries not available');
      }

      // Restore last viewed index from sessionStorage or start at 0
      const savedIndex = sessionStorage.getItem('deepDiveIndex');
      currentIndex = savedIndex ? parseInt(savedIndex, 10) : 0;
      if (currentIndex >= allEntries.length) currentIndex = 0;

      // Render the first entry
      renderCurrentEntry(container);
      
      // Add resize handler to re-render charts
      let resizeTimeout: number;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = window.setTimeout(() => {
          // Re-render current entry's charts
          if (allEntries.length > 0 && currentIndex < allEntries.length) {
            const entry = allEntries[currentIndex];
            const spotPrices = spotPricesMap.get(entry.symbol) || [];
            const pricePath = extractPricePath(entry, spotPrices);
            renderPriceChart(pricePath, entry.symbol);
            renderSentimentChart(entry.symbol);
          }
        }, 250);
      });
    } catch (error) {
      console.error('Deep dive error:', error);
      container.innerHTML = '<div class="error-state">Failed to load sample entry</div>';
    }
  });

  function renderCurrentEntry(container: HTMLElement) {
    const entry = allEntries[currentIndex];
    const spotPrices = spotPricesMap.get(entry.symbol) || [];
    
    // Save current index to sessionStorage
    sessionStorage.setItem('deepDiveIndex', currentIndex.toString());
    
    // Render the deep dive with navigation
    renderDeepDive(container, entry, spotPrices);
  }

  function navigateNext() {
    const container = document.getElementById('deepDiveContainer');
    if (!container || allEntries.length === 0) return;
    
    currentIndex = (currentIndex + 1) % allEntries.length;
    renderCurrentEntry(container);
  }

  function navigatePrevious() {
    const container = document.getElementById('deepDiveContainer');
    if (!container || allEntries.length === 0) return;
    
    currentIndex = (currentIndex - 1 + allEntries.length) % allEntries.length;
    renderCurrentEntry(container);
  }

  // Expose functions to window for button onclick handlers
  (window as any).navigateNext = navigateNext;
  (window as any).navigatePrevious = navigatePrevious;

  function renderDeepDive(container: HTMLElement, entry: any, spotPrices: any[]) {
    const metrics = calculateMetrics(entry, spotPrices);
    const pricePath = extractPricePath(entry, spotPrices);
    const sentimentPath = extractSentimentPath(entry);

    // Context data
    const duration = entry.meta?.duration_sec ? Math.round(entry.meta.duration_sec / 60) : null;
    const sentimentActivity = entry.twitter_sentiment_windows?.last_cycle?.sentiment_activity;
    const isSilent = sentimentActivity?.is_silent !== undefined ? sentimentActivity.is_silent : null;
    const futuresOk = entry.flags?.futures_data_ok !== undefined ? entry.flags.futures_data_ok : null;
    const liqGlobal = entry.derived?.liq_global_pct !== undefined ? entry.derived.liq_global_pct.toFixed(1) : null;
    const medianSpread = metrics.medianSpread !== null ? metrics.medianSpread.toFixed(2) : null;
    const spotSamplesCount = spotPrices.length;
    const postsLastCycle = entry.twitter_sentiment_windows?.last_cycle?.posts_total !== undefined ? 
      entry.twitter_sentiment_windows.last_cycle.posts_total : null;
    
    // Additional context fields
    const addedUtc = entry.meta?.added_ts 
      ? (typeof entry.meta.added_ts === 'string' ? entry.meta.added_ts : new Date(entry.meta.added_ts * 1000).toISOString().replace('.000Z', 'Z'))
      : null;
    const expiresUtc = entry.meta?.expires_ts 
      ? (typeof entry.meta.expires_ts === 'string' ? entry.meta.expires_ts : new Date(entry.meta.expires_ts * 1000).toISOString().replace('.000Z', 'Z'))
      : null;
    const durationSec = entry.meta?.duration_sec !== undefined ? entry.meta.duration_sec : null;
    
    // Calculate spot sampling interval (median delta between consecutive timestamps)
    let spotInterval = null;
    if (spotPrices.length >= 2) {
      const deltas = [];
      for (let i = 1; i < spotPrices.length; i++) {
        deltas.push(spotPrices[i].ts - spotPrices[i-1].ts);
      }
      deltas.sort((a, b) => a - b);
      const medianIdx = Math.floor(deltas.length / 2);
      spotInterval = deltas.length % 2 === 0 
        ? ((deltas[medianIdx - 1] + deltas[medianIdx]) / 2).toFixed(1)
        : deltas[medianIdx].toFixed(1);
    }
    
    // Get sentiment history count for this symbol
    const sentimentHistoryCount = sentimentTimeseriesMap.has(entry.symbol) 
      ? sentimentTimeseriesMap.get(entry.symbol)?.length 
      : null;

    // Context HTML
    const contextHTML = `
      <div class="context-section">
        <h3>Context</h3>
        <div class="context-grid">
          <div class="context-item">
            <span class="context-label">Symbol</span>
            <span class="context-value">${entry.symbol}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Added (UTC)</span>
            <span class="context-value">${addedUtc !== null ? addedUtc : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Expires (UTC)</span>
            <span class="context-value">${expiresUtc !== null ? expiresUtc : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Window duration (sec)</span>
            <span class="context-value">${durationSec !== null ? durationSec : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Silent</span>
            <span class="context-value">${isSilent !== null ? isSilent : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Futures data OK</span>
            <span class="context-value">${futuresOk !== null ? futuresOk : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Liquidity global (%)</span>
            <span class="context-value">${liqGlobal !== null ? liqGlobal : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Median spread (bps)</span>
            <span class="context-value">${medianSpread !== null ? medianSpread : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Posts (last_cycle)</span>
            <span class="context-value">${postsLastCycle !== null ? postsLastCycle : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Sentiment points (history)</span>
            <span class="context-value">${sentimentHistoryCount !== null ? sentimentHistoryCount : 'N/A'}</span>
          </div>
        </div>
      </div>
    `;

    // Metrics table rows
    const metricsRows = [
      ['Start price', metrics.startPrice !== null ? `$${formatMetric(metrics.startPrice, 4)}` : 'N/A'],
      ['End price', metrics.endPrice !== null ? `$${formatMetric(metrics.endPrice, 4)}` : 'N/A'],
      ['Absolute return (%)', formatMetric(metrics.absoluteReturn, 2)],
      ['Log return', formatMetric(metrics.logReturn, 4)],
      ['Maximum favorable excursion (MFE, %)', formatMetric(metrics.mfe, 2)],
      ['Maximum adverse excursion (MAE, %)', formatMetric(metrics.mae, 2)],
      ['Peak-to-trough drawdown (%)', formatMetric(metrics.drawdown, 2)],
      ['Realized volatility (session)', formatMetric(metrics.volatility, 4)],
      ['Median spread (bps)', formatMetric(metrics.medianSpread, 2)],
      ['Mean sentiment (hybrid, session)', formatMetric(metrics.meanSentiment, 4)]
    ];

    const metricsHTML = `
      <div class="metrics-section">
        <h3>Derived Metrics</h3>
        <table class="metrics-table">
          <tbody>
            ${metricsRows.map(([label, value]) => `
              <tr>
                <td class="metrics-label">${label}</td>
                <td class="metrics-value">${value}</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    `;

    // Navigation header
    const navHeader = `
      <div class="deep-dive-header-v2">
        <div class="deep-dive-header-row">
          <span class="deep-dive-symbol">${entry.symbol}</span>
          <span class="deep-dive-index">Entry ${currentIndex + 1} of ${allEntries.length}</span>
        </div>
        <div class="deep-dive-nav-row">
          <button class="deep-dive-btn" onclick="window.navigatePrevious()">
            <span>← Previous</span>
          </button>
          <button class="deep-dive-btn" onclick="window.navigateNext()">
            <span>Next →</span>
          </button>
        </div>
      </div>
    `;

    container.innerHTML = `
      ${navHeader}
      
      <div class="deep-dive-grid">
        ${contextHTML}
        ${metricsHTML}
      </div>
        
        <div class="chart-wrapper">
          <h3 class="chart-title">Spot price samples (latest active window)</h3>
          <div class="chart-panel">
            <canvas id="priceChart"></canvas>
            <div class="chart-tooltip" id="priceTooltip" hidden></div>
          </div>
          <p class="chart-caption">Spot prices sampled ~every 10 seconds during the monitoring window.</p>
        </div>
        
        <div class="chart-wrapper">
          <h3 class="chart-title">Sentiment history (hybrid mean)</h3>
          <div class="chart-panel">
            <canvas id="sentimentChart"></canvas>
            <div class="chart-tooltip" id="sentimentTooltip" hidden></div>
          </div>
          <p class="chart-caption">Aggregated entry-level sentiment over the observed archive period for this symbol.</p>
        </div>
    `;

    // Render charts
    requestAnimationFrame(() => {
      renderPriceChart(pricePath, entry.symbol);
      renderSentimentChart(entry.symbol);
    });
  }

  function renderPriceChart(pricePath: PricePoint[], symbol: string) {
    const canvas = document.getElementById('priceChart') as HTMLCanvasElement;
    const tooltip = document.getElementById('priceTooltip') as HTMLDivElement;
    if (!canvas || !tooltip) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Measure the parent container width (chart-panel)
    const panel = canvas.parentElement;
    if (!panel) return;
    
    const containerWidth = panel.clientWidth;
    const containerHeight = window.innerWidth <= 768 ? 300 : 360;

    // Set canvas size to match container (accounting for padding)
    canvas.width = Math.max(containerWidth - 36, 300); // 36px = 18px padding * 2
    canvas.height = containerHeight;

    if (pricePath.length === 0) {
      ctx.fillStyle = '#888888';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Price series not present in this sample entry.', canvas.width / 2, canvas.height / 2);
      return;
    }

    const padding = 50;
    const width = canvas.width - 2 * padding;
    const height = canvas.height - 2 * padding;

    // Use absolute prices
    const prices = pricePath.map(p => p.price);

    // Find ranges
    const minTime = Math.min(...pricePath.map(p => p.elapsed_min));
    const maxTime = Math.max(...pricePath.map(p => p.elapsed_min));
    const minPrice = Math.min(...prices);
    const maxPrice = Math.max(...prices);

    const priceRange = maxPrice - minPrice || 1;
    const timeRange = maxTime - minTime || 1;

    // Function to draw the chart
    function drawChart(highlightIndex?: number) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw axes
      ctx.strokeStyle = '#3a3a3a';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, padding + height);
      ctx.lineTo(padding + width, padding + height);
      ctx.stroke();

      // Draw price line
      ctx.strokeStyle = '#00bcd4';
      ctx.lineWidth = 2;
      ctx.beginPath();

      pricePath.forEach((point, i) => {
        const x = padding + ((point.elapsed_min - minTime) / timeRange) * width;
        const y = padding + height - ((point.price - minPrice) / priceRange) * height;

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });

      ctx.stroke();

      // Draw dots at data points
      pricePath.forEach((point, i) => {
        const x = padding + ((point.elapsed_min - minTime) / timeRange) * width;
        const y = padding + height - ((point.price - minPrice) / priceRange) * height;
        
        ctx.fillStyle = i === highlightIndex ? '#00e5ff' : '#00bcd4';
        ctx.beginPath();
        ctx.arc(x, y, i === highlightIndex ? 4 : 2, 0, 2 * Math.PI);
        ctx.fill();
      });

      // Labels
      ctx.fillStyle = '#b0b0b0';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Elapsed Time (minutes)', padding + width / 2, canvas.height - 5);
      
      ctx.save();
      ctx.translate(15, padding + height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Spot Price (USD)', 0, 0);
      ctx.restore();

      // Y-axis ticks
      ctx.textAlign = 'right';
      ctx.fillText('$' + minPrice.toFixed(4), padding - 5, padding + height);
      ctx.fillText('$' + maxPrice.toFixed(4), padding - 5, padding + 10);
    }

    drawChart();

    // Add DOM tooltip on mousemove
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // Find closest point
      let closestIndex = -1;
      let minDist = Infinity;

      pricePath.forEach((point, i) => {
        const x = padding + ((point.elapsed_min - minTime) / timeRange) * width;
        const y = padding + height - ((point.price - minPrice) / priceRange) * height;
        const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
        
        if (dist < minDist && dist < 25) {
          minDist = dist;
          closestIndex = i;
        }
      });

      if (closestIndex >= 0) {
        const point = pricePath[closestIndex];
        drawChart(closestIndex);
        
        tooltip.innerHTML = `Time: ${point.elapsed_min.toFixed(1)} min<br>Price: $${point.price.toFixed(6)}`;
        tooltip.hidden = false;
        tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
        tooltip.style.top = (e.clientY - rect.top - 40) + 'px';
        canvas.style.cursor = 'pointer';
      } else {
        drawChart();
        tooltip.hidden = true;
        canvas.style.cursor = 'default';
      }
    });

    canvas.addEventListener('mouseleave', () => {
      drawChart();
      tooltip.hidden = true;
      canvas.style.cursor = 'default';
    });
  }

  function renderSentimentChart(symbol: string) {
    const canvas = document.getElementById('sentimentChart') as HTMLCanvasElement;
    const tooltip = document.getElementById('sentimentTooltip') as HTMLDivElement;
    if (!canvas || !tooltip) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Measure the parent container width (chart-panel)
    const panel = canvas.parentElement;
    if (!panel) return;
    
    const containerWidth = panel.clientWidth;
    const containerHeight = window.innerWidth <= 768 ? 300 : 360;

    // Set canvas size to match container (accounting for padding)
    canvas.width = Math.max(containerWidth - 36, 300); // 36px = 18px padding * 2
    canvas.height = containerHeight;

    // Get timeseries for this symbol
    const timeseries = sentimentTimeseriesMap.get(symbol);
    
    if (!timeseries || timeseries.length === 0) {
      ctx.fillStyle = '#888888';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Sentiment timeseries not available for this symbol.', canvas.width / 2, canvas.height / 2);
      return;
    }

    // Filter out silent entries and convert timestamps to elapsed time
    const firstTs = new Date(timeseries[0].ts).getTime();
    const dataPoints = timeseries
      .filter(entry => !entry.is_silent && entry.mean_sent !== null)
      .map(entry => ({
        elapsed_hours: (new Date(entry.ts).getTime() - firstTs) / (1000 * 60 * 60),
        mean_sent: entry.mean_sent,
        posts: entry.posts,
        ts: entry.ts
      }));

    if (dataPoints.length === 0) {
      ctx.fillStyle = '#888888';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('No non-silent sentiment data for this symbol.', canvas.width / 2, canvas.height / 2);
      return;
    }

    const padding = 50;
    const width = canvas.width - 2 * padding;
    const height = canvas.height - 2 * padding;

    const minTime = 0;
    const maxTime = Math.max(...dataPoints.map(p => p.elapsed_hours));
    const timeRange = maxTime - minTime || 1;

    // Fixed sentiment range: -1 to +1
    const minSentiment = -1;
    const maxSentiment = 1;
    const sentimentRange = maxSentiment - minSentiment;
    const zeroY = padding + height - ((0 - minSentiment) / sentimentRange) * height;

    // Function to draw the chart
    function drawChart(highlightIndex?: number) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw axes
      ctx.strokeStyle = '#3a3a3a';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, padding + height);
      ctx.lineTo(padding + width, padding + height);
      ctx.stroke();

      // Draw zero line
      ctx.strokeStyle = '#555555';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(padding, zeroY);
      ctx.lineTo(padding + width, zeroY);
      ctx.stroke();
      ctx.setLineDash([]);

      // Draw sentiment line
      ctx.strokeStyle = '#00bcd4';
      ctx.lineWidth = 1.5;
      ctx.beginPath();

      dataPoints.forEach((point, i) => {
        const x = padding + (point.elapsed_hours / timeRange) * width;
        const y = padding + height - ((point.mean_sent - minSentiment) / sentimentRange) * height;

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });

      ctx.stroke();

      // Draw dots at data points
      dataPoints.forEach((point, i) => {
        const x = padding + (point.elapsed_hours / timeRange) * width;
        const y = padding + height - ((point.mean_sent - minSentiment) / sentimentRange) * height;
        
        ctx.fillStyle = i === highlightIndex ? '#00e5ff' : '#00bcd4';
        ctx.beginPath();
        ctx.arc(x, y, i === highlightIndex ? 4 : 2, 0, 2 * Math.PI);
        ctx.fill();
      });

      // Labels
      ctx.fillStyle = '#b0b0b0';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(`Time (hours from ${new Date(timeseries[0].ts).toISOString().split('T')[0]})`, padding + width / 2, canvas.height - 5);
      
      ctx.save();
      ctx.translate(15, padding + height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Mean Score (-1 to +1)', 0, 0);
      ctx.restore();

      // Y-axis ticks
      ctx.textAlign = 'right';
      ctx.fillText('-1.0', padding - 5, padding + height);
      ctx.fillText('0.0', padding - 5, zeroY + 5);
      ctx.fillText('+1.0', padding - 5, padding + 10);
    }

    drawChart();

    // Add DOM tooltip on mousemove
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // Find closest point
      let closestIndex = -1;
      let minDist = Infinity;

      dataPoints.forEach((point, i) => {
        const x = padding + (point.elapsed_hours / timeRange) * width;
        const y = padding + height - ((point.mean_sent - minSentiment) / sentimentRange) * height;
        const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
        
        if (dist < minDist && dist < 25) {
          minDist = dist;
          closestIndex = i;
        }
      });

      if (closestIndex >= 0) {
        const point = dataPoints[closestIndex];
        drawChart(closestIndex);
        
        const date = new Date(point.ts);
        const dateStr = date.toISOString().split('T')[0];
        const timeStr = date.toISOString().split('T')[1].split('.')[0];
        
        tooltip.innerHTML = `Date: ${dateStr} ${timeStr}<br>Sentiment: ${point.mean_sent.toFixed(4)}<br>Posts: ${point.posts}`;
        tooltip.hidden = false;
        tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
        tooltip.style.top = (e.clientY - rect.top - 50) + 'px';
        canvas.style.cursor = 'pointer';
      } else {
        drawChart();
        tooltip.hidden = true;
        canvas.style.cursor = 'default';
      }
    });

    canvas.addEventListener('mouseleave', () => {
      drawChart();
      tooltip.hidden = true;
      canvas.style.cursor = 'default';
    });
  }
</script>
