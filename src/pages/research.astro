---
import BaseLayout from '../layouts/BaseLayout.astro';
import PageHero from '../components/PageHero.astro';
---

<BaseLayout 
  title="Research & Methodology - Instrumetriq"
  description="How Instrumetriq collects and scores public X (Twitter) posts and aggregates signals into time windows."
>
  <PageHero
    eyebrow="RESEARCH"
    title="Research & Methodology"
    subtitle="How we collect and summarize sentiment signals, with ethics, privacy, and documentation as first principles."
  />
  <div class="pageContent">
    <!-- Section 1: Header -->
    <section>
      <h2>Overview</h2>
      <p>
        Instrumetriq observes short-lived market narratives by combining high-resolution market microstructure with aggregated social sentiment.
      </p>
      <p>
        Each asset is monitored ~120–130 minutes; spot price sampled every 10 seconds.
      </p>
      <p>
        This is an observational dataset: we publish measurements and derived statistics, not trading advice.
      </p>
    </section>

    <!-- Section 2: Hybrid Sentiment -->
    <section>
      <h2>How scoring works</h2>
      
      <h3>Data pipeline</h3>
      <ul>
        <li>Posts are collected for each asset via controlled queries.</li>
        <li>Posts are deduplicated.</li>
        <li>Each post is scored by TWO AI models (primary + referee).</li>
        <li>Referee confidence controls when we accept, override, or label neutral.</li>
        <li>Cycle-level aggregates are written (pos/neu/neg ratios, mean score, confidence stats).</li>
        <li>Silence handling is explicit (recent_posts_count, is_silent, hours_since_latest_tweet).</li>
      </ul>

      <h3>Hybrid decisions</h3>
      <div class="decision-legend">
        <div class="decision-item">
          <strong>primary_default</strong>
          <span>Primary model decision accepted</span>
        </div>
        <div class="decision-item">
          <strong>referee_override</strong>
          <span>Referee overrides primary</span>
        </div>
        <div class="decision-item">
          <strong>referee_neutral_band</strong>
          <span>Forced neutral due to uncertainty band</span>
        </div>
      </div>
      <p class="legend-note">
        These decision sources are tracked per cycle in hybrid_decision_stats.decision_sources.
      </p>
    </section>

    <!-- Section 3: What we store per entry -->
    <section>
      <h2>What we store per entry</h2>
      <div class="storage-grid">
        <div class="storage-card">
          <h3>Market microstructure</h3>
          <p>Spread, depth at multiple bps, order book imbalance, taker ratios.</p>
        </div>
        
        <div class="storage-card">
          <h3>Liquidity quality</h3>
          <p>liq_qv_usd plus global/self percentiles for regime comparisons.</p>
        </div>
        
        <div class="storage-card">
          <h3>Sentiment windows (aggregated)</h3>
          <p>last_cycle and last_2_cycles aggregates (not raw tweets), including author_stats and engagement.</p>
        </div>
        
        <div class="storage-card">
          <h3>Outcomes & derived features</h3>
          <p>Price-path metrics and derived entry statistics computed from the recorded series.</p>
        </div>
        
        <div class="storage-card">
          <h3>Activity & silence context</h3>
          <p>Explicit tracking of posting activity and silence states to distinguish absence of signal from neutral sentiment, including time since latest observed post.</p>
        </div>
        
        <div class="storage-card">
          <h3>Author & engagement aggregates</h3>
          <p>Aggregated author statistics and engagement signals (e.g. follower counts, verification flags, likes, replies, reposts). Author identities are not stored or exposed.</p>
        </div>
      </div>
    </section>

    <!-- Section 4: Entry Deep Dive -->
    <!-- deep-dive-v2: 2026-01-12 -->
    <section class="deep-dive deep-dive-v2">
      <h2>Entry Deep Dive (sample)</h2>
      <p class="deep-dive-subtitle">
        A rotating example from the public sample archive, illustrating how one monitored entry is represented end-to-end.
      </p>

      <div id="deepDiveContainer" 
           data-json="/data/sample_entries_v7.json"
           data-spots="/data/sample_entries_spots_v7.json">
        <div class="loading-state">Loading sample entry...</div>
      </div>
    </section>

    <!-- Section 5: Research use cases -->
    <section class="use-cases-section">
      <h2>Research use cases</h2>
      <p class="use-cases-subtitle">
        Examples of how the dataset can be used in research contexts.
      </p>

      <div class="use-cases-grid">
        <div class="use-case-card">
          <h3>Sentiment time series modeling</h3>
          <ul>
            <li>Use archived, window-level sentiment aggregates to study how social sentiment evolves over short, fixed monitoring periods.</li>
            <li>Analyze temporal properties such as persistence, volatility, mean reversion, and structural breaks in sentiment signals.</li>
            <li>Apply standard time-series techniques to social data that is already normalized and aggregated at the entry level.</li>
          </ul>
        </div>

        <div class="use-case-card">
          <h3>Microstructure + narrative coupling</h3>
          <ul>
            <li>Examine how aggregated social sentiment aligns with short-term price movement, spreads, and liquidity conditions.</li>
            <li>Study whether narrative intensity and market microstructure signals co-evolve, diverge, or lag one another.</li>
            <li>Compare coupling strength across assets, time windows, and market regimes.</li>
          </ul>
        </div>

        <div class="use-case-card">
          <h3>Silence & activity research</h3>
          <ul>
            <li>Explicitly separate periods of posting inactivity from neutral or low-confidence sentiment states.</li>
            <li>Analyze how changes in posting frequency relate to market behavior and volatility.</li>
            <li>Treat silence as a first-class signal rather than an absence of data.</li>
          </ul>
        </div>

        <div class="use-case-card">
          <h3>Model evaluation & drift monitoring</h3>
          <ul>
            <li>Use the historical archive to observe how sentiment model outputs behave over time.</li>
            <li>Track shifts in score distributions, confidence bands, and decision pathways.</li>
            <li>Support analysis of model stability, drift, and long-term consistency without retraining.</li>
          </ul>
        </div>

        <div class="use-case-card">
          <h3>Event-centric labeling (observational)</h3>
          <ul>
            <li>Identify recurring patterns in sentiment and market behavior around notable events.</li>
            <li>Analyze outcomes relative to observed entry conditions, rather than assigning forward-looking labels.</li>
            <li>Support retrospective research into how narratives and markets responded to specific situations.</li>
          </ul>
        </div>

        <div class="use-case-card">
          <h3>Cross-sectional comparisons</h3>
          <ul>
            <li>Compare sentiment, liquidity, and volatility metrics across multiple assets within similar time windows.</li>
            <li>Study relative behavior rather than absolute values to identify outliers and common structures.</li>
            <li>Analyze how different assets respond to comparable narrative conditions.</li>
          </ul>
        </div>

        <div class="use-case-card">
          <h3>Data quality & integrity studies</h3>
          <ul>
            <li>Evaluate completeness, internal consistency, and stability of collected signals.</li>
            <li>Study the effects of deduplication, aggregation, and sampling on downstream metrics.</li>
            <li>Use the dataset to validate methodological assumptions in social data collection.</li>
          </ul>
        </div>

        <div class="use-case-card">
          <h3>Aggregated author & engagement analysis</h3>
          <ul>
            <li>Analyze engagement dynamics using aggregated author-level statistics.</li>
            <li>Study how engagement concentration and distribution relate to sentiment outcomes.</li>
            <li>Preserve privacy by design: identities are neither stored nor exposed, only aggregated signals.</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- Section 6: Constraints & data integrity -->
    <section class="constraints-section">
      <h2>Constraints & data integrity</h2>

      <div class="constraint-block">
        <h3>Observational scope</h3>
        <p>
          This dataset is structured for observational research, not for trading decisions or predictive modeling advice. 
          The measurements record what occurred during specific monitoring windows, not what will occur.
        </p>
        <p>
          Outcomes are presented descriptively. Researchers using this data are expected to form their own interpretations 
          and validate findings independently. No statistical relationship observed here should be assumed to persist or generalize beyond the recorded conditions.
        </p>
      </div>

      <div class="constraint-block">
        <h3>Temporal & sampling limits</h3>
        <p>
          Each monitored entry spans approximately 120–130 minutes. Spot price samples are collected every 10 seconds during this window. 
          This is not continuous market coverage, and not all assets are monitored simultaneously.
        </p>
        <p>
          The dataset captures short-term, high-resolution snapshots rather than long-term trends. 
          Gaps between entries are expected and normal. Sampling frequency and window length are fixed by design, 
          which may limit certain analyses that require different temporal resolutions.
        </p>
      </div>

      <div class="constraint-block">
        <h3>Sentiment aggregation & uncertainty</h3>
        <p>
          Sentiment values are aggregated at the cycle level and do not represent individual posts. 
          A neutral sentiment score does not mean no social activity occurred—it may reflect balanced opinions, low confidence, or explicitly neutral content.
        </p>
        <p>
          Silence and inactivity are tracked separately using explicit flags and timestamps. 
          All sentiment scores carry inherent uncertainty and variance, which are reported alongside the aggregates. 
          Researchers should account for these distributions rather than treating aggregates as point estimates.
        </p>
      </div>

      <div class="constraint-block">
        <h3>Privacy & data handling</h3>
        <p>
          Raw posts are not stored in this dataset and are not published or exposed. 
          Author identities are not recorded, stored, or made available at any stage of the pipeline.
        </p>
        <p>
          Only aggregated author-level statistics (such as follower count distributions, verification ratios, and engagement metrics) 
          are included, preserving privacy by design. The source data is public, but processing follows data minimization principles 
          to ensure no individual-level tracking or re-identification is possible from the published archive.
        </p>
      </div>
    </section>

    <!-- Section 7: Intended use & closure -->
    <section class="intended-use-section">
      <h2>How this dataset is intended to be used</h2>
      <p>
        This dataset is designed for research, analysis, and experimentation. It provides a structured foundation for 
        studying how aggregated social sentiment relates to short-term price behavior, liquidity conditions, and market microstructure. 
        Researchers can use it to test hypotheses, build analytical tools, evaluate models, or create benchmarks for sentiment 
        and activity signals in cryptocurrency markets.
      </p>
      <p>
        It is not a replacement for real-time market data feeds, execution systems, or trading infrastructure. 
        The archive contains fixed snapshots captured under specific conditions, not a continuous stream of updated signals. 
        Value comes from the structure, consistency, and transparency of the measurements—not from predictive claims or 
        forward-looking guarantees.
      </p>
      <p>
        If you are conducting observational research into social sentiment dynamics, exploring the relationship between 
        narrative and market behavior, or validating methodologies for aggregated signal collection, this dataset may be relevant. 
        It is intended for those who need reproducible, well-documented data to support rigorous analytical work.
      </p>
    </section>
  </div>
</BaseLayout>

<style is:global>
  section {
    margin-bottom: var(--space-8);
  }

  h2 {
    font-size: var(--font-size-2xl);
    margin-bottom: var(--space-4);
    color: var(--text);
  }

  h3 {
    font-size: var(--font-size-xl);
    margin-top: var(--space-5);
    margin-bottom: var(--space-3);
    color: var(--text);
  }

  p {
    line-height: 1.6;
    color: var(--text-muted);
    margin-bottom: var(--space-3);
  }

  ul {
    line-height: 1.7;
    color: var(--text-muted);
    margin: var(--space-3) 0;
    padding-left: var(--space-5);
  }

  li {
    margin-bottom: var(--space-2);
  }

  /* Hybrid decisions legend */
  .decision-legend {
    display: flex;
    flex-direction: column;
    gap: var(--space-3);
    margin: var(--space-4) 0;
    padding: var(--space-4);
    background-color: var(--panel2);
    border-radius: 4px;
  }

  .decision-item {
    display: flex;
    flex-direction: column;
    gap: var(--space-1);
  }

  .decision-item strong {
    color: var(--accent);
    font-size: 0.9375rem;
    font-family: monospace;
  }

  .decision-item span {
    color: var(--text-muted);
    font-size: 0.875rem;
  }

  .legend-note {
    font-size: 0.875rem;
    color: var(--text-dim);
    font-style: italic;
    margin-top: var(--space-2);
  }

  /* Storage cards grid */
  .storage-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: var(--space-4);
    margin-top: var(--space-4);
  }

  .storage-card {
    padding: var(--space-4);
    background-color: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 4px;
    transition: border-color var(--transition-base);
  }

  .storage-card:hover {
    border-color: var(--border2);
  }

  .storage-card h3 {
    font-size: 1.125rem;
    margin: 0 0 var(--space-2) 0;
    color: var(--text);
  }

  .storage-card p {
    font-size: 0.9375rem;
    line-height: 1.5;
    margin: 0;
    color: var(--text-muted);
  }

  @media (max-width: 768px) {
    .storage-grid {
      grid-template-columns: 1fr;
    }
  }

  /* Research use cases grid */
  .use-cases-subtitle {
    font-size: 0.9375rem;
    color: var(--text-muted);
    margin-bottom: var(--space-5);
  }

  .use-cases-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: var(--space-4);
    margin-top: var(--space-4);
  }

  .use-case-card {
    padding: var(--space-4);
    background-color: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 4px;
    transition: border-color var(--transition-base);
    display: flex;
    flex-direction: column;
  }

  .use-case-card:hover {
    border-color: var(--border2);
  }

  .use-case-card h3 {
    font-size: 1.125rem;
    margin: 0 0 var(--space-3) 0;
    color: var(--text);
  }

  .use-case-card ul {
    margin: 0;
    padding-left: var(--space-5);
    flex-grow: 1;
  }

  .use-case-card li {
    font-size: 0.875rem;
    line-height: 1.5;
    color: var(--text-muted);
    margin-bottom: var(--space-2);
  }

  .use-case-card li:last-child {
    margin-bottom: 0;
  }

  @media (max-width: 768px) {
    .use-cases-grid {
      grid-template-columns: 1fr;
    }
  }

  /* Constraints & data integrity section */
  .constraint-block {
    margin-bottom: var(--space-6);
  }

  .constraint-block:last-child {
    margin-bottom: 0;
  }

  .constraint-block h3 {
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--text);
    margin: 0 0 var(--space-3) 0;
  }

  .constraint-block p {
    font-size: 0.9375rem;
    line-height: 1.65;
    color: var(--text-muted);
    margin-bottom: var(--space-3);
  }

  .constraint-block p:last-child {
    margin-bottom: 0;
  }

  /* Deep Dive Section */
  .deep-dive-subtitle {
    font-size: 0.9375rem;
    color: var(--text-muted);
    font-style: italic;
    margin-bottom: var(--space-5);
  }

  /* Deep dive navigation */
  .deep-dive-nav {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--space-4);
    padding: var(--space-4);
    background-color: var(--bg);
    border-bottom: 1px solid var(--border);
    margin-bottom: var(--space-6);
  }

  .deep-dive-nav .nav-info {
    flex: 1;
    text-align: center;
  }

  .deep-dive-nav .nav-info .symbol-title {
    font-size: 1.75rem;
    font-weight: 600;
    color: var(--text);
    display: block;
    margin-bottom: var(--space-1);
  }

  .deep-dive-nav .nav-counter {
    font-size: 0.875rem;
    color: var(--text-muted);
  }

  /* Deep Dive V2 - New Layout */
  .deep-dive-v2 .deep-dive-header-v2 {
    background-color: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: var(--space-5);
    margin-bottom: var(--space-6);
  }

  .deep-dive-v2 .deep-dive-header-row {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    gap: 16px;
    margin-bottom: var(--space-3);
  }

  .deep-dive-v2 .deep-dive-symbol {
    font-family: inherit;
    font-size: 32px;
    font-weight: 700;
    color: var(--text);
    letter-spacing: 0.2px;
  }

  .deep-dive-v2 .deep-dive-index {
    opacity: 0.7;
    font-size: 14px;
    color: var(--text-muted);
    white-space: nowrap;
  }

  .deep-dive-v2 .deep-dive-nav-row {
    display: flex;
    gap: 12px;
    margin-top: 10px;
  }

  .deep-dive-v2 .deep-dive-btn {
    padding: 10px 14px;
    border-radius: 12px;
    border: 1px solid var(--border);
    background: rgba(255, 255, 255, 0.02);
    color: var(--text);
    font-size: 0.9375rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
  }

  .deep-dive-v2 .deep-dive-btn:hover {
    border-color: var(--accent);
    background: rgba(0, 188, 212, 0.1);
  }

  .deep-dive-v2 .deep-dive-btn:focus {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
  }

  @media (max-width: 768px) {
    .deep-dive-v2 .deep-dive-header-row {
      flex-direction: column;
      align-items: flex-start;
    }
    
    .deep-dive-v2 .deep-dive-nav-row {
      width: 100%;
    }
    
    .deep-dive-v2 .deep-dive-btn {
      flex: 1;
    }
  }

  .nav-btn {
    padding: var(--space-3) var(--space-5);
    background-color: var(--panel);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
    font-size: 0.9375rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
    display: inline-flex;
    align-items: center;
    gap: var(--space-2);
  }

  .nav-btn:hover {
    background-color: var(--accent);
    border-color: var(--accent);
    color: var(--bg);
    box-shadow: 0 2px 8px rgba(0, 188, 212, 0.3);
  }

  .nav-btn:active {
    transform: translateY(1px);
  }

  .nav-btn:focus {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
  }

  @media (max-width: 768px) {
    .deep-dive-nav {
      flex-direction: column;
      gap: var(--space-3);
    }

    .deep-dive-nav .nav-info {
      order: -1;
      width: 100%;
    }

    .nav-btn {
      width: 100%;
      justify-content: center;
    }
  }

  /* Context and Metrics grid */
  .context-metrics-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-6);
    margin-bottom: var(--space-6);
  }

  .deep-dive-v2 .deep-dive-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 28px;
    align-items: start;
    margin-bottom: var(--space-6);
  }

  @media (max-width: 768px) {
    .context-metrics-grid {
      grid-template-columns: 1fr;
      gap: var(--space-5);
    }
    
    .deep-dive-v2 .deep-dive-grid {
      grid-template-columns: 1fr;
      gap: var(--space-5);
    }
  }

  .context-section,
  .metrics-section {
    background-color: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: var(--space-4);
  }

  .context-section h3,
  .metrics-section h3 {
    font-size: 1.125rem;
    font-weight: 600;
    margin-bottom: var(--space-4);
    color: var(--text);
    border-bottom: 1px solid var(--border);
    padding-bottom: var(--space-2);
  }

  .context-grid {
    display: table;
    width: 100%;
    border-collapse: collapse;
  }

  .context-item {
    display: table-row;
  }

  .context-label,
  .context-value {
    display: table-cell;
    padding: 12px 8px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    line-height: 1.4;
  }

  .context-item:last-child .context-label,
  .context-item:last-child .context-value {
    border-bottom: none;
  }

  .context-label {
    font-size: 0.875rem;
    color: var(--text-muted);
    font-weight: 400;
    padding-right: var(--space-4);
    width: 70%;
  }

  .context-value {
    font-size: 0.9375rem;
    color: var(--text);
    font-weight: 600;
    text-align: right;
    white-space: nowrap;
  }

  .loading-state {
    padding: var(--space-6);
    text-align: center;
    color: var(--text-muted);
  }

  .error-state {
    padding: var(--space-6);
    text-align: center;
    color: #ef4444;
  }

  .deep-dive-content {
    display: flex;
    flex-direction: column;
    gap: var(--space-6);
  }

  /* Context Badges */
  .context-badges {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-2);
    margin-bottom: var(--space-4);
  }

  .context-badge {
    padding: var(--space-2) var(--space-3);
    background-color: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 4px;
    font-size: 0.875rem;
    color: var(--text-muted);
  }

  .context-badge strong {
    color: var(--text);
    margin-right: var(--space-1);
  }

  /* Charts */
  .chart-container {
    margin-bottom: var(--space-6);
    width: 100%;
  }

  .chart-wrapper {
    margin-bottom: var(--space-6);
    width: 100%;
    max-width: 100%;
  }

  .chart-title {
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--text);
    margin-bottom: var(--space-3);
  }

  .chart-panel {
    width: 100%;
    max-width: 100%;
    padding: 18px;
    border: 1px solid var(--border);
    border-radius: 16px;
    background: rgba(255, 255, 255, 0.02);
    position: relative;
  }

  .chart-panel canvas {
    display: block;
  }

  .chart-tooltip {
    position: absolute;
    background: #111;
    border: 1px solid var(--accent);
    padding: 8px 10px;
    border-radius: 10px;
    font-size: 12px;
    color: var(--text);
    pointer-events: none;
    white-space: nowrap;
    z-index: 10;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  }

  .chart-canvas {
    width: 100%;
    height: 400px;
    min-height: 350px;
    background-color: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 6px;
    display: block;
  }

  @media (max-width: 768px) {
    .chart-canvas {
      height: 320px;
      min-height: 280px;
    }
  }

  .chart-caption {
    margin-top: var(--space-2);
    font-size: 0.8125rem;
    color: var(--text-dim);
    font-style: italic;
  }

  /* Metrics Table */
  .metrics-table {
    width: 100%;
    border-collapse: collapse;
  }

  .metrics-table td {
    padding: 12px 8px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    line-height: 1.4;
  }

  .metrics-table tr:last-child td {
    border-bottom: none;
  }

  .metrics-table .metrics-label {
    color: var(--text-muted);
    font-size: 0.875rem;
    font-weight: 400;
    padding-right: var(--space-4);
    width: 70%;
  }

  .metrics-table .metrics-value {
    text-align: right;
    font-family: monospace;
    color: var(--text);
    font-size: 0.9375rem;
    font-weight: 600;
    white-space: nowrap;
  }
</style>

<script>
  // Entry Deep Dive - Client-side rendering with navigation
  import { extractPricePath, extractSentimentPath, calculateMetrics, formatMetric, type PricePoint, type SentimentPoint } from '../lib/deriveEntryMetrics';

  let allEntries: any[] = [];
  let spotPricesMap: Map<string, any[]> = new Map();
  let sentimentTimeseriesMap: Map<string, any[]> = new Map();
  let currentIndex = 0;

  document.addEventListener('DOMContentLoaded', async () => {
    const container = document.getElementById('deepDiveContainer');
    if (!container) return;

    const jsonUrl = container.getAttribute('data-json');
    const spotsUrl = container.getAttribute('data-spots');
    const timeseriesUrl = '/data/sample_symbols_sentiment_timeseries.json';
    
    if (!jsonUrl || !spotsUrl) {
      container.innerHTML = '<div class="error-state">Configuration error: missing data URL</div>';
      return;
    }

    try {
      // Fetch entries, spot prices, and sentiment timeseries
      const [entriesResponse, spotsResponse, timeseriesResponse] = await Promise.all([
        fetch(jsonUrl),
        fetch(spotsUrl),
        fetch(timeseriesUrl)
      ]);

      if (!entriesResponse.ok || !spotsResponse.ok) {
        throw new Error('Failed to load data');
      }

      const entriesData = await entriesResponse.json();
      const spotsData = await spotsResponse.json();
      
      allEntries = entriesData.entries || [];
      const spots = spotsData.spots || [];

      if (allEntries.length === 0) {
        container.innerHTML = '<div class="error-state">No entries available</div>';
        return;
      }

      // Build spot prices lookup by symbol
      spots.forEach((spot: any) => {
        if (spot.symbol && spot.spot_prices) {
          spotPricesMap.set(spot.symbol, spot.spot_prices);
        }
      });

      // Load sentiment timeseries if available
      if (timeseriesResponse.ok) {
        const timeseriesData = await timeseriesResponse.json();
        const seriesBySymbol = timeseriesData.series_by_symbol || {};
        Object.keys(seriesBySymbol).forEach(symbol => {
          sentimentTimeseriesMap.set(symbol, seriesBySymbol[symbol]);
        });
        console.log(`[INFO] Loaded sentiment timeseries for ${sentimentTimeseriesMap.size} symbols`);
      } else {
        console.warn('[WARN] Sentiment timeseries not available');
      }

      // Restore last viewed index from sessionStorage or start at 0
      const savedIndex = sessionStorage.getItem('deepDiveIndex');
      currentIndex = savedIndex ? parseInt(savedIndex, 10) : 0;
      if (currentIndex >= allEntries.length) currentIndex = 0;

      // Render the first entry
      renderCurrentEntry(container);
      
      // Add resize handler to re-render charts
      let resizeTimeout: number;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = window.setTimeout(() => {
          // Re-render current entry's charts
          if (allEntries.length > 0 && currentIndex < allEntries.length) {
            const entry = allEntries[currentIndex];
            const spotPrices = spotPricesMap.get(entry.symbol) || [];
            const pricePath = extractPricePath(entry, spotPrices);
            renderPriceChart(pricePath, entry.symbol);
            renderSentimentChart(entry.symbol);
          }
        }, 250);
      });
    } catch (error) {
      console.error('Deep dive error:', error);
      container.innerHTML = '<div class="error-state">Failed to load sample entry</div>';
    }
  });

  function renderCurrentEntry(container: HTMLElement) {
    const entry = allEntries[currentIndex];
    const spotPrices = spotPricesMap.get(entry.symbol) || [];
    
    // Save current index to sessionStorage
    sessionStorage.setItem('deepDiveIndex', currentIndex.toString());
    
    // Render the deep dive with navigation
    renderDeepDive(container, entry, spotPrices);
  }

  function navigateNext() {
    const container = document.getElementById('deepDiveContainer');
    if (!container || allEntries.length === 0) return;
    
    currentIndex = (currentIndex + 1) % allEntries.length;
    renderCurrentEntry(container);
  }

  function navigatePrevious() {
    const container = document.getElementById('deepDiveContainer');
    if (!container || allEntries.length === 0) return;
    
    currentIndex = (currentIndex - 1 + allEntries.length) % allEntries.length;
    renderCurrentEntry(container);
  }

  // Expose functions to window for button onclick handlers
  (window as any).navigateNext = navigateNext;
  (window as any).navigatePrevious = navigatePrevious;

  function renderDeepDive(container: HTMLElement, entry: any, spotPrices: any[]) {
    const metrics = calculateMetrics(entry, spotPrices);
    const pricePath = extractPricePath(entry, spotPrices);
    const sentimentPath = extractSentimentPath(entry);

    // Context data
    const duration = entry.meta?.duration_sec ? Math.round(entry.meta.duration_sec / 60) : null;
    const sentimentActivity = entry.twitter_sentiment_windows?.last_cycle?.sentiment_activity;
    const isSilent = sentimentActivity?.is_silent !== undefined ? sentimentActivity.is_silent : null;
    const futuresOk = entry.flags?.futures_data_ok !== undefined ? entry.flags.futures_data_ok : null;
    const liqGlobal = entry.derived?.liq_global_pct !== undefined ? entry.derived.liq_global_pct.toFixed(1) : null;
    const medianSpread = metrics.medianSpread !== null ? metrics.medianSpread.toFixed(2) : null;
    const spotSamplesCount = spotPrices.length;
    const postsLastCycle = entry.twitter_sentiment_windows?.last_cycle?.posts_total !== undefined ? 
      entry.twitter_sentiment_windows.last_cycle.posts_total : null;
    
    // Additional context fields
    const addedUtc = entry.meta?.added_ts 
      ? (typeof entry.meta.added_ts === 'string' ? entry.meta.added_ts : new Date(entry.meta.added_ts * 1000).toISOString().replace('.000Z', 'Z'))
      : null;
    const expiresUtc = entry.meta?.expires_ts 
      ? (typeof entry.meta.expires_ts === 'string' ? entry.meta.expires_ts : new Date(entry.meta.expires_ts * 1000).toISOString().replace('.000Z', 'Z'))
      : null;
    const durationSec = entry.meta?.duration_sec !== undefined ? entry.meta.duration_sec : null;
    
    // Calculate spot sampling interval (median delta between consecutive timestamps)
    let spotInterval = null;
    if (spotPrices.length >= 2) {
      const deltas = [];
      for (let i = 1; i < spotPrices.length; i++) {
        deltas.push(spotPrices[i].ts - spotPrices[i-1].ts);
      }
      deltas.sort((a, b) => a - b);
      const medianIdx = Math.floor(deltas.length / 2);
      spotInterval = deltas.length % 2 === 0 
        ? ((deltas[medianIdx - 1] + deltas[medianIdx]) / 2).toFixed(1)
        : deltas[medianIdx].toFixed(1);
    }
    
    // Get sentiment history count for this symbol
    const sentimentHistoryCount = sentimentTimeseriesMap.has(entry.symbol) 
      ? sentimentTimeseriesMap.get(entry.symbol)?.length 
      : null;

    // Context HTML
    const contextHTML = `
      <div class="context-section">
        <h3>Context</h3>
        <div class="context-grid">
          <div class="context-item">
            <span class="context-label">Symbol</span>
            <span class="context-value">${entry.symbol}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Added (UTC)</span>
            <span class="context-value">${addedUtc !== null ? addedUtc : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Expires (UTC)</span>
            <span class="context-value">${expiresUtc !== null ? expiresUtc : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Window duration (sec)</span>
            <span class="context-value">${durationSec !== null ? durationSec : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Silent</span>
            <span class="context-value">${isSilent !== null ? isSilent : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Futures data OK</span>
            <span class="context-value">${futuresOk !== null ? futuresOk : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Liquidity global (%)</span>
            <span class="context-value">${liqGlobal !== null ? liqGlobal : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Median spread (bps)</span>
            <span class="context-value">${medianSpread !== null ? medianSpread : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Posts (last_cycle)</span>
            <span class="context-value">${postsLastCycle !== null ? postsLastCycle : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Sentiment points (history)</span>
            <span class="context-value">${sentimentHistoryCount !== null ? sentimentHistoryCount : 'N/A'}</span>
          </div>
        </div>
      </div>
    `;

    // Metrics table rows
    const metricsRows = [
      ['Start price', metrics.startPrice !== null ? `$${formatMetric(metrics.startPrice, 4)}` : 'N/A'],
      ['End price', metrics.endPrice !== null ? `$${formatMetric(metrics.endPrice, 4)}` : 'N/A'],
      ['Absolute return (%)', formatMetric(metrics.absoluteReturn, 2)],
      ['Log return', formatMetric(metrics.logReturn, 4)],
      ['Maximum favorable excursion (MFE, %)', formatMetric(metrics.mfe, 2)],
      ['Maximum adverse excursion (MAE, %)', formatMetric(metrics.mae, 2)],
      ['Peak-to-trough drawdown (%)', formatMetric(metrics.drawdown, 2)],
      ['Realized volatility (session)', formatMetric(metrics.volatility, 4)],
      ['Median spread (bps)', formatMetric(metrics.medianSpread, 2)],
      ['Mean sentiment (hybrid, session)', formatMetric(metrics.meanSentiment, 4)]
    ];

    const metricsHTML = `
      <div class="metrics-section">
        <h3>Derived Metrics</h3>
        <table class="metrics-table">
          <tbody>
            ${metricsRows.map(([label, value]) => `
              <tr>
                <td class="metrics-label">${label}</td>
                <td class="metrics-value">${value}</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    `;

    // Navigation header
    const navHeader = `
      <div class="deep-dive-header-v2">
        <div class="deep-dive-header-row">
          <span class="deep-dive-symbol">${entry.symbol}</span>
          <span class="deep-dive-index">Entry ${currentIndex + 1} of ${allEntries.length}</span>
        </div>
        <div class="deep-dive-nav-row">
          <button class="deep-dive-btn" onclick="window.navigatePrevious()">
            <span>← Previous</span>
          </button>
          <button class="deep-dive-btn" onclick="window.navigateNext()">
            <span>Next →</span>
          </button>
        </div>
      </div>
    `;

    container.innerHTML = `
      ${navHeader}
      
      <div class="deep-dive-grid">
        ${contextHTML}
        ${metricsHTML}
      </div>
        
        <div class="chart-wrapper">
          <h3 class="chart-title">Spot price samples (latest active window)</h3>
          <div class="chart-panel">
            <canvas id="priceChart"></canvas>
            <div class="chart-tooltip" id="priceTooltip" hidden></div>
          </div>
          <p class="chart-caption">Spot prices sampled ~every 10 seconds during the monitoring window.</p>
        </div>
        
        <div class="chart-wrapper">
          <h3 class="chart-title">Sentiment history (hybrid mean)</h3>
          <div class="chart-panel">
            <canvas id="sentimentChart"></canvas>
            <div class="chart-tooltip" id="sentimentTooltip" hidden></div>
          </div>
          <p class="chart-caption">Aggregated entry-level sentiment over the observed archive period for this symbol.</p>
        </div>
    `;

    // Render charts
    requestAnimationFrame(() => {
      renderPriceChart(pricePath, entry.symbol);
      renderSentimentChart(entry.symbol);
    });
  }

  function renderPriceChart(pricePath: PricePoint[], symbol: string) {
    const canvas = document.getElementById('priceChart') as HTMLCanvasElement;
    const tooltip = document.getElementById('priceTooltip') as HTMLDivElement;
    if (!canvas || !tooltip) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Measure the parent container width (chart-panel)
    const panel = canvas.parentElement;
    if (!panel) return;
    
    const containerWidth = panel.clientWidth;
    const containerHeight = window.innerWidth <= 768 ? 300 : 360;

    // Set canvas size to match container (accounting for padding)
    canvas.width = Math.max(containerWidth - 36, 300); // 36px = 18px padding * 2
    canvas.height = containerHeight;

    if (pricePath.length === 0) {
      ctx.fillStyle = '#888888';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Price series not present in this sample entry.', canvas.width / 2, canvas.height / 2);
      return;
    }

    const padding = 50;
    const width = canvas.width - 2 * padding;
    const height = canvas.height - 2 * padding;

    // Use absolute prices
    const prices = pricePath.map(p => p.price);

    // Find ranges
    const minTime = Math.min(...pricePath.map(p => p.elapsed_min));
    const maxTime = Math.max(...pricePath.map(p => p.elapsed_min));
    const minPrice = Math.min(...prices);
    const maxPrice = Math.max(...prices);

    const priceRange = maxPrice - minPrice || 1;
    const timeRange = maxTime - minTime || 1;

    // Function to draw the chart
    function drawChart(highlightIndex?: number) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw axes
      ctx.strokeStyle = '#3a3a3a';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, padding + height);
      ctx.lineTo(padding + width, padding + height);
      ctx.stroke();

      // Draw price line
      ctx.strokeStyle = '#00bcd4';
      ctx.lineWidth = 2;
      ctx.beginPath();

      pricePath.forEach((point, i) => {
        const x = padding + ((point.elapsed_min - minTime) / timeRange) * width;
        const y = padding + height - ((point.price - minPrice) / priceRange) * height;

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });

      ctx.stroke();

      // Draw dots at data points
      pricePath.forEach((point, i) => {
        const x = padding + ((point.elapsed_min - minTime) / timeRange) * width;
        const y = padding + height - ((point.price - minPrice) / priceRange) * height;
        
        ctx.fillStyle = i === highlightIndex ? '#00e5ff' : '#00bcd4';
        ctx.beginPath();
        ctx.arc(x, y, i === highlightIndex ? 4 : 2, 0, 2 * Math.PI);
        ctx.fill();
      });

      // Labels
      ctx.fillStyle = '#b0b0b0';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Elapsed Time (minutes)', padding + width / 2, canvas.height - 5);
      
      ctx.save();
      ctx.translate(15, padding + height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Spot Price (USD)', 0, 0);
      ctx.restore();

      // Y-axis ticks
      ctx.textAlign = 'right';
      ctx.fillText('$' + minPrice.toFixed(4), padding - 5, padding + height);
      ctx.fillText('$' + maxPrice.toFixed(4), padding - 5, padding + 10);
    }

    drawChart();

    // Add DOM tooltip on mousemove
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // Find closest point
      let closestIndex = -1;
      let minDist = Infinity;

      pricePath.forEach((point, i) => {
        const x = padding + ((point.elapsed_min - minTime) / timeRange) * width;
        const y = padding + height - ((point.price - minPrice) / priceRange) * height;
        const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
        
        if (dist < minDist && dist < 25) {
          minDist = dist;
          closestIndex = i;
        }
      });

      if (closestIndex >= 0) {
        const point = pricePath[closestIndex];
        drawChart(closestIndex);
        
        tooltip.innerHTML = `Time: ${point.elapsed_min.toFixed(1)} min<br>Price: $${point.price.toFixed(6)}`;
        tooltip.hidden = false;
        tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
        tooltip.style.top = (e.clientY - rect.top - 40) + 'px';
        canvas.style.cursor = 'pointer';
      } else {
        drawChart();
        tooltip.hidden = true;
        canvas.style.cursor = 'default';
      }
    });

    canvas.addEventListener('mouseleave', () => {
      drawChart();
      tooltip.hidden = true;
      canvas.style.cursor = 'default';
    });
  }

  function renderSentimentChart(symbol: string) {
    const canvas = document.getElementById('sentimentChart') as HTMLCanvasElement;
    const tooltip = document.getElementById('sentimentTooltip') as HTMLDivElement;
    if (!canvas || !tooltip) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Measure the parent container width (chart-panel)
    const panel = canvas.parentElement;
    if (!panel) return;
    
    const containerWidth = panel.clientWidth;
    const containerHeight = window.innerWidth <= 768 ? 300 : 360;

    // Set canvas size to match container (accounting for padding)
    canvas.width = Math.max(containerWidth - 36, 300); // 36px = 18px padding * 2
    canvas.height = containerHeight;

    // Get timeseries for this symbol
    const timeseries = sentimentTimeseriesMap.get(symbol);
    
    if (!timeseries || timeseries.length === 0) {
      ctx.fillStyle = '#888888';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Sentiment timeseries not available for this symbol.', canvas.width / 2, canvas.height / 2);
      return;
    }

    // Filter out silent entries and convert timestamps to elapsed time
    const firstTs = new Date(timeseries[0].ts).getTime();
    const dataPoints = timeseries
      .filter(entry => !entry.is_silent && entry.mean_sent !== null)
      .map(entry => ({
        elapsed_hours: (new Date(entry.ts).getTime() - firstTs) / (1000 * 60 * 60),
        mean_sent: entry.mean_sent,
        posts: entry.posts,
        ts: entry.ts
      }));

    if (dataPoints.length === 0) {
      ctx.fillStyle = '#888888';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('No non-silent sentiment data for this symbol.', canvas.width / 2, canvas.height / 2);
      return;
    }

    const padding = 50;
    const width = canvas.width - 2 * padding;
    const height = canvas.height - 2 * padding;

    const minTime = 0;
    const maxTime = Math.max(...dataPoints.map(p => p.elapsed_hours));
    const timeRange = maxTime - minTime || 1;

    // Fixed sentiment range: -1 to +1
    const minSentiment = -1;
    const maxSentiment = 1;
    const sentimentRange = maxSentiment - minSentiment;
    const zeroY = padding + height - ((0 - minSentiment) / sentimentRange) * height;

    // Function to draw the chart
    function drawChart(highlightIndex?: number) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw axes
      ctx.strokeStyle = '#3a3a3a';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, padding + height);
      ctx.lineTo(padding + width, padding + height);
      ctx.stroke();

      // Draw zero line
      ctx.strokeStyle = '#555555';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(padding, zeroY);
      ctx.lineTo(padding + width, zeroY);
      ctx.stroke();
      ctx.setLineDash([]);

      // Draw sentiment line
      ctx.strokeStyle = '#00bcd4';
      ctx.lineWidth = 1.5;
      ctx.beginPath();

      dataPoints.forEach((point, i) => {
        const x = padding + (point.elapsed_hours / timeRange) * width;
        const y = padding + height - ((point.mean_sent - minSentiment) / sentimentRange) * height;

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });

      ctx.stroke();

      // Draw dots at data points
      dataPoints.forEach((point, i) => {
        const x = padding + (point.elapsed_hours / timeRange) * width;
        const y = padding + height - ((point.mean_sent - minSentiment) / sentimentRange) * height;
        
        ctx.fillStyle = i === highlightIndex ? '#00e5ff' : '#00bcd4';
        ctx.beginPath();
        ctx.arc(x, y, i === highlightIndex ? 4 : 2, 0, 2 * Math.PI);
        ctx.fill();
      });

      // Labels
      ctx.fillStyle = '#b0b0b0';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(`Time (hours from ${new Date(timeseries[0].ts).toISOString().split('T')[0]})`, padding + width / 2, canvas.height - 5);
      
      ctx.save();
      ctx.translate(15, padding + height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Mean Score (-1 to +1)', 0, 0);
      ctx.restore();

      // Y-axis ticks
      ctx.textAlign = 'right';
      ctx.fillText('-1.0', padding - 5, padding + height);
      ctx.fillText('0.0', padding - 5, zeroY + 5);
      ctx.fillText('+1.0', padding - 5, padding + 10);
    }

    drawChart();

    // Add DOM tooltip on mousemove
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // Find closest point
      let closestIndex = -1;
      let minDist = Infinity;

      dataPoints.forEach((point, i) => {
        const x = padding + (point.elapsed_hours / timeRange) * width;
        const y = padding + height - ((point.mean_sent - minSentiment) / sentimentRange) * height;
        const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
        
        if (dist < minDist && dist < 25) {
          minDist = dist;
          closestIndex = i;
        }
      });

      if (closestIndex >= 0) {
        const point = dataPoints[closestIndex];
        drawChart(closestIndex);
        
        const date = new Date(point.ts);
        const dateStr = date.toISOString().split('T')[0];
        const timeStr = date.toISOString().split('T')[1].split('.')[0];
        
        tooltip.innerHTML = `Date: ${dateStr} ${timeStr}<br>Sentiment: ${point.mean_sent.toFixed(4)}<br>Posts: ${point.posts}`;
        tooltip.hidden = false;
        tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
        tooltip.style.top = (e.clientY - rect.top - 50) + 'px';
        canvas.style.cursor = 'pointer';
      } else {
        drawChart();
        tooltip.hidden = true;
        canvas.style.cursor = 'default';
      }
    });

    canvas.addEventListener('mouseleave', () => {
      drawChart();
      tooltip.hidden = true;
      canvas.style.cursor = 'default';
    });
  }
</script>
