---
import BaseLayout from '../layouts/BaseLayout.astro';
import PageHero from '../components/PageHero.astro';
---

<BaseLayout 
  title="Research & Methodology - Instrumetriq"
  description="How Instrumetriq collects and scores public X (Twitter) posts and aggregates signals into time windows."
>
  <PageHero
    eyebrow="RESEARCH"
    title="Research & Methodology"
    subtitle="How we collect and summarize sentiment signals, with ethics, privacy, and documentation as first principles."
  />
  <div class="pageContent">
    <!-- Section 1: Header -->
    <section>
      <h2>Overview</h2>
      <p>
        Instrumetriq observes short-lived market narratives by combining high-resolution market microstructure with aggregated social sentiment.
      </p>
      <p>
        Each asset is monitored ~120–130 minutes; spot price sampled every 10 seconds.
      </p>
      <p>
        This is an observational dataset: we publish measurements and derived statistics, not trading advice.
      </p>
    </section>

    <!-- Section 2: Hybrid Sentiment -->
    <section>
      <h2>How scoring works</h2>
      
      <h3>Data pipeline</h3>
      <ul>
        <li>Posts are collected for each asset via controlled queries.</li>
        <li>Posts are deduplicated.</li>
        <li>Each post is scored by TWO AI models (primary + referee).</li>
        <li>Referee confidence controls when we accept, override, or label neutral.</li>
        <li>Cycle-level aggregates are written (pos/neu/neg ratios, mean score, confidence stats).</li>
        <li>Silence handling is explicit (recent_posts_count, is_silent, hours_since_latest_tweet).</li>
      </ul>

      <h3>Hybrid decisions</h3>
      <div class="decision-legend">
        <div class="decision-item">
          <strong>primary_default</strong>
          <span>Primary model decision accepted</span>
        </div>
        <div class="decision-item">
          <strong>referee_override</strong>
          <span>Referee overrides primary</span>
        </div>
        <div class="decision-item">
          <strong>referee_neutral_band</strong>
          <span>Forced neutral due to uncertainty band</span>
        </div>
      </div>
      <p class="legend-note">
        These decision sources are tracked per cycle in hybrid_decision_stats.decision_sources.
      </p>
    </section>

    <!-- Section 3: What we store per entry -->
    <section>
      <h2>What we store per entry</h2>
      <div class="storage-grid">
        <div class="storage-card">
          <h3>Market microstructure</h3>
          <p>Spread, depth at multiple bps, order book imbalance, taker ratios.</p>
        </div>
        
        <div class="storage-card">
          <h3>Liquidity quality</h3>
          <p>liq_qv_usd plus global/self percentiles for regime comparisons.</p>
        </div>
        
        <div class="storage-card">
          <h3>Sentiment windows (aggregated)</h3>
          <p>last_cycle and last_2_cycles aggregates (not raw tweets), including author_stats and engagement.</p>
        </div>
        
        <div class="storage-card">
          <h3>Outcomes & derived features</h3>
          <p>Price-path metrics and derived entry statistics computed from the recorded series.</p>
        </div>
        
        <div class="storage-card">
          <h3>Activity & silence context</h3>
          <p>Explicit tracking of posting activity and silence states to distinguish absence of signal from neutral sentiment, including time since latest observed post.</p>
        </div>
        
        <div class="storage-card">
          <h3>Author & engagement aggregates</h3>
          <p>Aggregated author statistics and engagement signals (e.g. follower counts, verification flags, likes, replies, reposts). Author identities are not stored or exposed.</p>
        </div>
      </div>
    </section>

    <!-- Section 4: Entry Deep Dive -->
    <section>
      <h2>Entry Deep Dive (sample)</h2>
      <p class="deep-dive-subtitle">
        A rotating example from the public sample archive, illustrating how one monitored entry is represented end-to-end.
      </p>

      <div id="deepDiveContainer" 
           data-json="/data/sample_entries_v7.json"
           data-spots="/data/sample_entries_spots_v7.json">
        <div class="loading-state">Loading sample entry...</div>
      </div>
    </section>
  </div>
</BaseLayout>

<style>
  section {
    margin-bottom: var(--space-8);
  }

  h2 {
    font-size: var(--font-size-2xl);
    margin-bottom: var(--space-4);
    color: var(--text);
  }

  h3 {
    font-size: var(--font-size-xl);
    margin-top: var(--space-5);
    margin-bottom: var(--space-3);
    color: var(--text);
  }

  p {
    line-height: 1.6;
    color: var(--text-muted);
    margin-bottom: var(--space-3);
  }

  ul {
    line-height: 1.7;
    color: var(--text-muted);
    margin: var(--space-3) 0;
    padding-left: var(--space-5);
  }

  li {
    margin-bottom: var(--space-2);
  }

  /* Hybrid decisions legend */
  .decision-legend {
    display: flex;
    flex-direction: column;
    gap: var(--space-3);
    margin: var(--space-4) 0;
    padding: var(--space-4);
    background-color: var(--panel2);
    border-radius: 4px;
  }

  .decision-item {
    display: flex;
    flex-direction: column;
    gap: var(--space-1);
  }

  .decision-item strong {
    color: var(--accent);
    font-size: 0.9375rem;
    font-family: monospace;
  }

  .decision-item span {
    color: var(--text-muted);
    font-size: 0.875rem;
  }

  .legend-note {
    font-size: 0.875rem;
    color: var(--text-dim);
    font-style: italic;
    margin-top: var(--space-2);
  }

  /* Storage cards grid */
  .storage-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: var(--space-4);
    margin-top: var(--space-4);
  }

  .storage-card {
    padding: var(--space-4);
    background-color: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 4px;
    transition: border-color var(--transition-base);
  }

  .storage-card:hover {
    border-color: var(--border2);
  }

  .storage-card h3 {
    font-size: 1.125rem;
    margin: 0 0 var(--space-2) 0;
    color: var(--text);
  }

  .storage-card p {
    font-size: 0.9375rem;
    line-height: 1.5;
    margin: 0;
    color: var(--text-muted);
  }

  @media (max-width: 768px) {
    .storage-grid {
      grid-template-columns: 1fr;
    }
  }

  /* Deep Dive Section */
  .deep-dive-subtitle {
    font-size: 0.9375rem;
    color: var(--text-muted);
    font-style: italic;
    margin-bottom: var(--space-5);
  }

  /* Deep dive navigation */
  .deep-dive-nav {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--space-4);
    padding: var(--space-4);
    background-color: var(--bg);
    border-bottom: 1px solid var(--border);
    margin-bottom: var(--space-6);
  }

  .deep-dive-nav .nav-info {
    flex: 1;
    text-align: center;
  }

  .deep-dive-nav .nav-info .symbol-title {
    font-size: 1.5rem;
    font-weight: 600;
    color: var(--accent);
    font-family: 'Courier New', monospace;
    display: block;
    margin-bottom: var(--space-1);
  }

  .deep-dive-nav .nav-counter {
    font-size: 0.875rem;
    color: var(--text-muted);
  }

  .nav-btn {
    padding: var(--space-3) var(--space-5);
    background-color: var(--panel);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
    font-size: 0.9375rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
    display: inline-flex;
    align-items: center;
    gap: var(--space-2);
  }

  .nav-btn:hover {
    background-color: var(--accent);
    border-color: var(--accent);
    color: var(--bg);
    box-shadow: 0 2px 8px rgba(0, 188, 212, 0.3);
  }

  .nav-btn:active {
    transform: translateY(1px);
  }

  .nav-btn:focus {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
  }

  @media (max-width: 768px) {
    .deep-dive-nav {
      flex-direction: column;
      gap: var(--space-3);
    }

    .deep-dive-nav .nav-info {
      order: -1;
      width: 100%;
    }

    .nav-btn {
      width: 100%;
      justify-content: center;
    }
  }

  /* Context and Metrics grid */
  .context-metrics-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-6);
    margin-bottom: var(--space-6);
  }

  @media (max-width: 968px) {
    .context-metrics-grid {
      grid-template-columns: 1fr;
      gap: var(--space-5);
    }
  }

  .context-section,
  .metrics-section {
    background-color: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: var(--space-4);
  }

  .context-section h3,
  .metrics-section h3 {
    font-size: 1.125rem;
    font-weight: 600;
    margin-bottom: var(--space-4);
    color: var(--text);
    border-bottom: 1px solid var(--border);
    padding-bottom: var(--space-2);
  }

  .context-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: var(--space-3);
  }

  .context-item {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    padding: var(--space-2) 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  }

  .context-item:last-child {
    border-bottom: none;
  }

  .context-label {
    font-size: 0.875rem;
    color: var(--text-muted);
    font-weight: 500;
  }

  .context-value {
    font-size: 0.9375rem;
    color: var(--text);
    font-family: 'Courier New', monospace;
    font-weight: 500;
  }

  .loading-state {
    padding: var(--space-6);
    text-align: center;
    color: var(--text-muted);
  }

  .error-state {
    padding: var(--space-6);
    text-align: center;
    color: #ef4444;
  }

  .deep-dive-content {
    display: flex;
    flex-direction: column;
    gap: var(--space-6);
  }

  /* Context Badges */
  .context-badges {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-2);
    margin-bottom: var(--space-4);
  }

  .context-badge {
    padding: var(--space-2) var(--space-3);
    background-color: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 4px;
    font-size: 0.875rem;
    color: var(--text-muted);
  }

  .context-badge strong {
    color: var(--text);
    margin-right: var(--space-1);
  }

  /* Charts */
  .chart-container {
    margin-bottom: var(--space-6);
    width: 100%;
  }

  .chart-title {
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--text);
    margin-bottom: var(--space-3);
  }

  .chart-canvas {
    width: 100%;
    height: 400px;
    min-height: 350px;
    background-color: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 6px;
    display: block;
  }

  @media (max-width: 768px) {
    .chart-canvas {
      height: 320px;
      min-height: 280px;
    }
  }

  .chart-caption {
    margin-top: var(--space-2);
    font-size: 0.8125rem;
    color: var(--text-dim);
    font-style: italic;
  }

  /* Metrics Table */
  /* Metrics Table */
  .metrics-table {
    width: 100%;
    border-collapse: collapse;
  }

  .metrics-table td {
    padding: var(--space-2) 0;
    border-bottom: 1px solid var(--border);
  }

  .metrics-table tr:last-child td {
    border-bottom: none;
  }

  .metrics-table .metrics-label {
    color: var(--text-muted);
    font-size: 0.875rem;
  }

  .metrics-table .metrics-value {
    text-align: right;
    font-family: monospace;
    color: var(--text);
    font-size: 0.9375rem;
  }
</style>

<script>
  // Entry Deep Dive - Client-side rendering with navigation
  import { extractPricePath, extractSentimentPath, calculateMetrics, formatMetric, type PricePoint, type SentimentPoint } from '../lib/deriveEntryMetrics';

  let allEntries: any[] = [];
  let spotPricesMap: Map<string, any[]> = new Map();
  let sentimentTimeseriesMap: Map<string, any[]> = new Map();
  let currentIndex = 0;

  document.addEventListener('DOMContentLoaded', async () => {
    const container = document.getElementById('deepDiveContainer');
    if (!container) return;

    const jsonUrl = container.getAttribute('data-json');
    const spotsUrl = container.getAttribute('data-spots');
    const timeseriesUrl = '/data/sample_symbols_sentiment_timeseries.json';
    
    if (!jsonUrl || !spotsUrl) {
      container.innerHTML = '<div class="error-state">Configuration error: missing data URL</div>';
      return;
    }

    try {
      // Fetch entries, spot prices, and sentiment timeseries
      const [entriesResponse, spotsResponse, timeseriesResponse] = await Promise.all([
        fetch(jsonUrl),
        fetch(spotsUrl),
        fetch(timeseriesUrl)
      ]);

      if (!entriesResponse.ok || !spotsResponse.ok) {
        throw new Error('Failed to load data');
      }

      const entriesData = await entriesResponse.json();
      const spotsData = await spotsResponse.json();
      
      allEntries = entriesData.entries || [];
      const spots = spotsData.spots || [];

      if (allEntries.length === 0) {
        container.innerHTML = '<div class="error-state">No entries available</div>';
        return;
      }

      // Build spot prices lookup by symbol
      spots.forEach((spot: any) => {
        if (spot.symbol && spot.spot_prices) {
          spotPricesMap.set(spot.symbol, spot.spot_prices);
        }
      });

      // Load sentiment timeseries if available
      if (timeseriesResponse.ok) {
        const timeseriesData = await timeseriesResponse.json();
        const seriesBySymbol = timeseriesData.series_by_symbol || {};
        Object.keys(seriesBySymbol).forEach(symbol => {
          sentimentTimeseriesMap.set(symbol, seriesBySymbol[symbol]);
        });
        console.log(`[INFO] Loaded sentiment timeseries for ${sentimentTimeseriesMap.size} symbols`);
      } else {
        console.warn('[WARN] Sentiment timeseries not available');
      }

      // Restore last viewed index from sessionStorage or start at 0
      const savedIndex = sessionStorage.getItem('deepDiveIndex');
      currentIndex = savedIndex ? parseInt(savedIndex, 10) : 0;
      if (currentIndex >= allEntries.length) currentIndex = 0;

      // Render the first entry
      renderCurrentEntry(container);
    } catch (error) {
      console.error('Deep dive error:', error);
      container.innerHTML = '<div class="error-state">Failed to load sample entry</div>';
    }
  });

  function renderCurrentEntry(container: HTMLElement) {
    const entry = allEntries[currentIndex];
    const spotPrices = spotPricesMap.get(entry.symbol) || [];
    
    // Save current index to sessionStorage
    sessionStorage.setItem('deepDiveIndex', currentIndex.toString());
    
    // Render the deep dive with navigation
    renderDeepDive(container, entry, spotPrices);
  }

  function navigateNext() {
    const container = document.getElementById('deepDiveContainer');
    if (!container || allEntries.length === 0) return;
    
    currentIndex = (currentIndex + 1) % allEntries.length;
    renderCurrentEntry(container);
  }

  function navigatePrevious() {
    const container = document.getElementById('deepDiveContainer');
    if (!container || allEntries.length === 0) return;
    
    currentIndex = (currentIndex - 1 + allEntries.length) % allEntries.length;
    renderCurrentEntry(container);
  }

  // Expose functions to window for button onclick handlers
  (window as any).navigateNext = navigateNext;
  (window as any).navigatePrevious = navigatePrevious;

  function renderDeepDive(container: HTMLElement, entry: any, spotPrices: any[]) {
    const metrics = calculateMetrics(entry, spotPrices);
    const pricePath = extractPricePath(entry, spotPrices);
    const sentimentPath = extractSentimentPath(entry);

    // Context data
    const duration = entry.meta?.duration_sec ? Math.round(entry.meta.duration_sec / 60) : null;
    const sentimentActivity = entry.twitter_sentiment_windows?.last_cycle?.sentiment_activity;
    const isSilent = sentimentActivity?.is_silent !== undefined ? sentimentActivity.is_silent : null;
    const futuresOk = entry.flags?.futures_data_ok !== undefined ? entry.flags.futures_data_ok : null;
    const liqGlobal = entry.derived?.liq_global_pct !== undefined ? entry.derived.liq_global_pct.toFixed(1) : null;
    const medianSpread = metrics.medianSpread !== null ? metrics.medianSpread.toFixed(2) : null;
    const spotSamplesCount = spotPrices.length;
    const postsLastCycle = entry.twitter_sentiment_windows?.last_cycle?.posts_total !== undefined ? 
      entry.twitter_sentiment_windows.last_cycle.posts_total : null;

    // Context HTML
    const contextHTML = `
      <div class="context-section">
        <h3>Context</h3>
        <div class="context-grid">
          <div class="context-item">
            <span class="context-label">Symbol</span>
            <span class="context-value">${entry.symbol}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Duration (min)</span>
            <span class="context-value">${duration !== null ? duration : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">is_silent</span>
            <span class="context-value">${isSilent !== null ? isSilent : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">futures_data_ok</span>
            <span class="context-value">${futuresOk !== null ? futuresOk : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Liquidity global percentile (%)</span>
            <span class="context-value">${liqGlobal !== null ? liqGlobal : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Median spread (bps)</span>
            <span class="context-value">${medianSpread !== null ? medianSpread : 'N/A'}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Spot samples (count)</span>
            <span class="context-value">${spotSamplesCount}</span>
          </div>
          <div class="context-item">
            <span class="context-label">Posts in last_cycle</span>
            <span class="context-value">${postsLastCycle !== null ? postsLastCycle : 'N/A'}</span>
          </div>
        </div>
      </div>
    `;

    // Metrics table rows
    const metricsRows = [
      ['Start price', metrics.startPrice !== null ? `$${formatMetric(metrics.startPrice, 4)}` : 'N/A'],
      ['End price', metrics.endPrice !== null ? `$${formatMetric(metrics.endPrice, 4)}` : 'N/A'],
      ['Absolute return (%)', formatMetric(metrics.absoluteReturn, 2)],
      ['Log return', formatMetric(metrics.logReturn, 4)],
      ['Maximum favorable excursion (MFE, %)', formatMetric(metrics.mfe, 2)],
      ['Maximum adverse excursion (MAE, %)', formatMetric(metrics.mae, 2)],
      ['Peak-to-trough drawdown (%)', formatMetric(metrics.drawdown, 2)],
      ['Realized volatility (session)', formatMetric(metrics.volatility, 4)],
      ['Median spread (bps)', formatMetric(metrics.medianSpread, 2)],
      ['Mean sentiment (hybrid, session)', formatMetric(metrics.meanSentiment, 4)]
    ];

    const metricsHTML = `
      <div class="metrics-section">
        <h3>Derived Metrics</h3>
        <table class="metrics-table">
          <tbody>
            ${metricsRows.map(([label, value]) => `
              <tr>
                <td class="metrics-label">${label}</td>
                <td class="metrics-value">${value}</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    `;

    // Navigation header
    const navHeader = `
      <div class="deep-dive-nav">
        <button class="nav-btn" onclick="window.navigatePrevious()">
          <span>←</span>
          <span>Previous</span>
        </button>
        <div class="nav-info">
          <span class="symbol-title">${entry.symbol}</span>
          <span class="nav-counter">Entry ${currentIndex + 1} of ${allEntries.length}</span>
        </div>
        <button class="nav-btn" onclick="window.navigateNext()">
          <span>Next</span>
          <span>→</span>
        </button>
      </div>
    `;

    container.innerHTML = `
      <div class="deep-dive-content">
        ${navHeader}
        
        <div class="context-metrics-grid">
          ${contextHTML}
          ${metricsHTML}
        </div>
        
        <div class="chart-container">
          <h3 class="chart-title">Return from Start</h3>
          <canvas id="priceChart" class="chart-canvas"></canvas>
        </div>
        
        <div class="chart-container">
          <h3 class="chart-title">Sentiment Over Time</h3>
          <canvas id="sentimentChart" class="chart-canvas"></canvas>
          <p class="chart-caption">Sentiment shown as aggregated window scores, not individual posts.</p>
        </div>
      </div>
    `;

    // Render charts
    requestAnimationFrame(() => {
      renderPriceChart(pricePath, entry.symbol);
      renderSentimentChart(entry.symbol);
    });
  }

  function renderPriceChart(pricePath: PricePoint[], symbol: string) {
    const canvas = document.getElementById('priceChart') as HTMLCanvasElement;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Set canvas size
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    if (pricePath.length === 0) {
      ctx.fillStyle = '#888888';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Price series not present in this sample entry.', canvas.width / 2, canvas.height / 2);
      return;
    }

    const padding = 40;
    const width = canvas.width - 2 * padding;
    const height = canvas.height - 2 * padding;

    // Calculate return % from initial price
    const initialPrice = pricePath[0].price;
    const returns = pricePath.map(p => ((p.price - initialPrice) / initialPrice) * 100);

    // Find ranges
    const minTime = Math.min(...pricePath.map(p => p.elapsed_min));
    const maxTime = Math.max(...pricePath.map(p => p.elapsed_min));
    const minReturn = Math.min(...returns);
    const maxReturn = Math.max(...returns);

    const returnRange = maxReturn - minReturn || 1; // Avoid division by zero
    const timeRange = maxTime - minTime || 1;

    // Draw axes
    ctx.strokeStyle = '#3a3a3a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, padding + height);
    ctx.lineTo(padding + width, padding + height);
    ctx.stroke();

    // Draw zero line if it's in range
    if (minReturn < 0 && maxReturn > 0) {
      const zeroY = padding + height - ((0 - minReturn) / returnRange) * height;
      ctx.strokeStyle = '#4a4a4a';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(padding, zeroY);
      ctx.lineTo(padding + width, zeroY);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Draw return line
    ctx.strokeStyle = '#00bcd4';
    ctx.lineWidth = 2;
    ctx.beginPath();

    pricePath.forEach((point, i) => {
      const x = padding + ((point.elapsed_min - minTime) / timeRange) * width;
      const y = padding + height - ((returns[i] - minReturn) / returnRange) * height;

      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });

    ctx.stroke();

    // Labels
    ctx.fillStyle = '#b0b0b0';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Elapsed Time (minutes)', padding + width / 2, canvas.height - 5);
    
    ctx.save();
    ctx.translate(15, padding + height / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Return (%)', 0, 0);
    ctx.restore();

    // Y-axis ticks
    ctx.textAlign = 'right';
    ctx.fillText(minReturn.toFixed(2) + '%', padding - 5, padding + height);
    ctx.fillText(maxReturn.toFixed(2) + '%', padding - 5, padding + 10);
  }

  function renderSentimentChart(symbol: string) {
    const canvas = document.getElementById('sentimentChart') as HTMLCanvasElement;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    // Get timeseries for this symbol
    const timeseries = sentimentTimeseriesMap.get(symbol);
    
    if (!timeseries || timeseries.length === 0) {
      ctx.fillStyle = '#888888';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Sentiment timeseries not available for this symbol.', canvas.width / 2, canvas.height / 2);
      return;
    }

    // Filter out silent entries and convert timestamps to elapsed time
    const firstTs = new Date(timeseries[0].ts).getTime();
    const dataPoints = timeseries
      .filter(entry => !entry.is_silent && entry.mean_sent !== null)
      .map(entry => ({
        elapsed_hours: (new Date(entry.ts).getTime() - firstTs) / (1000 * 60 * 60),
        mean_sent: entry.mean_sent,
        posts: entry.posts
      }));

    if (dataPoints.length === 0) {
      ctx.fillStyle = '#888888';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('No non-silent sentiment data for this symbol.', canvas.width / 2, canvas.height / 2);
      return;
    }

    const padding = 40;
    const width = canvas.width - 2 * padding;
    const height = canvas.height - 2 * padding;

    const minTime = 0;
    const maxTime = Math.max(...dataPoints.map(p => p.elapsed_hours));
    const timeRange = maxTime - minTime || 1;

    // Fixed sentiment range: -1 to +1
    const minSentiment = -1;
    const maxSentiment = 1;
    const sentimentRange = maxSentiment - minSentiment;

    // Draw axes
    ctx.strokeStyle = '#3a3a3a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, padding + height);
    ctx.lineTo(padding + width, padding + height);
    ctx.stroke();

    // Draw zero line
    ctx.strokeStyle = '#555555';
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);
    const zeroY = padding + height - ((0 - minSentiment) / sentimentRange) * height;
    ctx.beginPath();
    ctx.moveTo(padding, zeroY);
    ctx.lineTo(padding + width, zeroY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Draw sentiment line
    ctx.strokeStyle = '#00bcd4';
    ctx.lineWidth = 1.5;
    ctx.beginPath();

    dataPoints.forEach((point, i) => {
      const x = padding + (point.elapsed_hours / timeRange) * width;
      const y = padding + height - ((point.mean_sent - minSentiment) / sentimentRange) * height;

      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });

    ctx.stroke();

    // Draw dots at data points
    ctx.fillStyle = '#00bcd4';
    dataPoints.forEach((point) => {
      const x = padding + (point.elapsed_hours / timeRange) * width;
      const y = padding + height - ((point.mean_sent - minSentiment) / sentimentRange) * height;
      
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, 2 * Math.PI);
      ctx.fill();
    });

    // Labels
    ctx.fillStyle = '#b0b0b0';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`Time (hours from ${new Date(timeseries[0].ts).toISOString().split('T')[0]})`, padding + width / 2, canvas.height - 5);
    
    ctx.save();
    ctx.translate(15, padding + height / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Mean Score (-1 to +1)', 0, 0);
    ctx.restore();

    // Y-axis ticks
    ctx.textAlign = 'right';
    ctx.fillText('-1.0', padding - 5, padding + height);
    ctx.fillText('0.0', padding - 5, zeroY + 5);
    ctx.fillText('+1.0', padding - 5, padding + 10);
  }
</script>
