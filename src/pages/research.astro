---
import BaseLayout from '../layouts/BaseLayout.astro';
import PageHero from '../components/PageHero.astro';
---

<BaseLayout 
  title="Research & Methodology - Instrumetriq"
  description="How Instrumetriq collects and scores public X (Twitter) posts and aggregates signals into time windows."
>
  <PageHero
    eyebrow="RESEARCH"
    title="Research & Methodology"
    subtitle="How we collect and summarize sentiment signals, with ethics, privacy, and documentation as first principles."
  />
  <div class="pageContent">
    <!-- Section 1: Header -->
    <section>
      <h2>Overview</h2>
      <p>
        Instrumetriq observes short-lived market narratives by combining high-resolution market microstructure with aggregated social sentiment.
      </p>
      <p>
        Each asset is monitored ~120â€“130 minutes; spot price sampled every 10 seconds.
      </p>
      <p>
        This is an observational dataset: we publish measurements and derived statistics, not trading advice.
      </p>
    </section>

    <!-- Section 2: Hybrid Sentiment -->
    <section>
      <h2>How scoring works</h2>
      
      <h3>Data pipeline</h3>
      <ul>
        <li>Posts are collected for each asset via controlled queries.</li>
        <li>Posts are deduplicated.</li>
        <li>Each post is scored by TWO AI models (primary + referee).</li>
        <li>Referee confidence controls when we accept, override, or label neutral.</li>
        <li>Cycle-level aggregates are written (pos/neu/neg ratios, mean score, confidence stats).</li>
        <li>Silence handling is explicit (recent_posts_count, is_silent, hours_since_latest_tweet).</li>
      </ul>

      <h3>Hybrid decisions</h3>
      <div class="decision-legend">
        <div class="decision-item">
          <strong>primary_default</strong>
          <span>Primary model decision accepted</span>
        </div>
        <div class="decision-item">
          <strong>referee_override</strong>
          <span>Referee overrides primary</span>
        </div>
        <div class="decision-item">
          <strong>referee_neutral_band</strong>
          <span>Forced neutral due to uncertainty band</span>
        </div>
      </div>
      <p class="legend-note">
        These decision sources are tracked per cycle in hybrid_decision_stats.decision_sources.
      </p>
    </section>

    <!-- Section 3: What we store per entry -->
    <section>
      <h2>What we store per entry</h2>
      <div class="storage-grid">
        <div class="storage-card">
          <h3>Market microstructure</h3>
          <p>Spread, depth at multiple bps, order book imbalance, taker ratios.</p>
        </div>
        
        <div class="storage-card">
          <h3>Liquidity quality</h3>
          <p>liq_qv_usd plus global/self percentiles for regime comparisons.</p>
        </div>
        
        <div class="storage-card">
          <h3>Sentiment windows (aggregated)</h3>
          <p>last_cycle and last_2_cycles aggregates (not raw tweets), including author_stats and engagement.</p>
        </div>
        
        <div class="storage-card">
          <h3>Outcomes & derived features</h3>
          <p>Price-path metrics and derived entry statistics computed from the recorded series.</p>
        </div>
        
        <div class="storage-card">
          <h3>Activity & silence context</h3>
          <p>Explicit tracking of posting activity and silence states to distinguish absence of signal from neutral sentiment, including time since latest observed post.</p>
        </div>
        
        <div class="storage-card">
          <h3>Author & engagement aggregates</h3>
          <p>Aggregated author statistics and engagement signals (e.g. follower counts, verification flags, likes, replies, reposts). Author identities are not stored or exposed.</p>
        </div>
      </div>
    </section>

    <!-- Section 4: Entry Deep Dive -->
    <section>
      <h2>Entry Deep Dive (sample)</h2>
      <p class="deep-dive-subtitle">
        A rotating example from the public sample archive, illustrating how one monitored entry is represented end-to-end.
      </p>

      <div id="deepDiveContainer" 
           data-json="/data/sample_entries_v7.json"
           data-spots="/data/sample_entries_spots_v7.json">
        <div class="loading-state">Loading sample entry...</div>
      </div>
    </section>
  </div>
</BaseLayout>

<style>
  section {
    margin-bottom: var(--space-8);
  }

  h2 {
    font-size: var(--font-size-2xl);
    margin-bottom: var(--space-4);
    color: var(--text);
  }

  h3 {
    font-size: var(--font-size-xl);
    margin-top: var(--space-5);
    margin-bottom: var(--space-3);
    color: var(--text);
  }

  p {
    line-height: 1.6;
    color: var(--text-muted);
    margin-bottom: var(--space-3);
  }

  ul {
    line-height: 1.7;
    color: var(--text-muted);
    margin: var(--space-3) 0;
    padding-left: var(--space-5);
  }

  li {
    margin-bottom: var(--space-2);
  }

  /* Hybrid decisions legend */
  .decision-legend {
    display: flex;
    flex-direction: column;
    gap: var(--space-3);
    margin: var(--space-4) 0;
    padding: var(--space-4);
    background-color: var(--panel2);
    border-radius: 4px;
  }

  .decision-item {
    display: flex;
    flex-direction: column;
    gap: var(--space-1);
  }

  .decision-item strong {
    color: var(--accent);
    font-size: 0.9375rem;
    font-family: monospace;
  }

  .decision-item span {
    color: var(--text-muted);
    font-size: 0.875rem;
  }

  .legend-note {
    font-size: 0.875rem;
    color: var(--text-dim);
    font-style: italic;
    margin-top: var(--space-2);
  }

  /* Storage cards grid */
  .storage-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: var(--space-4);
    margin-top: var(--space-4);
  }

  .storage-card {
    padding: var(--space-4);
    background-color: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 4px;
    transition: border-color var(--transition-base);
  }

  .storage-card:hover {
    border-color: var(--border2);
  }

  .storage-card h3 {
    font-size: 1.125rem;
    margin: 0 0 var(--space-2) 0;
    color: var(--text);
  }

  .storage-card p {
    font-size: 0.9375rem;
    line-height: 1.5;
    margin: 0;
    color: var(--text-muted);
  }

  @media (max-width: 768px) {
    .storage-grid {
      grid-template-columns: 1fr;
    }
  }

  /* Deep Dive Section */
  .deep-dive-subtitle {
    font-size: 0.9375rem;
    color: var(--text-muted);
    font-style: italic;
    margin-bottom: var(--space-5);
  }

  .loading-state {
    padding: var(--space-6);
    text-align: center;
    color: var(--text-muted);
  }

  .error-state {
    padding: var(--space-6);
    text-align: center;
    color: #ef4444;
  }

  .deep-dive-content {
    display: flex;
    flex-direction: column;
    gap: var(--space-6);
  }

  /* Context Badges */
  .context-badges {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-2);
    margin-bottom: var(--space-4);
  }

  .context-badge {
    padding: var(--space-2) var(--space-3);
    background-color: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 4px;
    font-size: 0.875rem;
    color: var(--text-muted);
  }

  .context-badge strong {
    color: var(--text);
    margin-right: var(--space-1);
  }

  /* Charts */
  .chart-container {
    background-color: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: var(--space-4);
  }

  .chart-title {
    font-size: 1rem;
    font-weight: 600;
    color: var(--text);
    margin-bottom: var(--space-3);
  }

  .chart-canvas {
    width: 100%;
    height: 300px;
    background-color: var(--bg);
    border-radius: 4px;
  }

  .chart-caption {
    margin-top: var(--space-2);
    font-size: 0.8125rem;
    color: var(--text-dim);
    font-style: italic;
  }

  /* Metrics Table */
  .metrics-table-container {
    background-color: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: var(--space-4);
  }

  .metrics-table {
    width: 100%;
    border-collapse: collapse;
  }

  .metrics-table th,
  .metrics-table td {
    padding: var(--space-2) var(--space-3);
    text-align: left;
    border-bottom: 1px solid var(--border);
  }

  .metrics-table th {
    font-weight: 600;
    color: var(--text);
    font-size: 0.875rem;
  }

  .metrics-table td {
    color: var(--text-muted);
    font-size: 0.9375rem;
  }

  .metrics-table tr:last-child th,
  .metrics-table tr:last-child td {
    border-bottom: none;
  }

  .metrics-table td:last-child {
    text-align: right;
    font-family: monospace;
  }
</style>

<script>
  // Entry Deep Dive - Client-side rendering
  import { extractPricePath, extractSentimentPath, calculateMetrics, formatMetric, type PricePoint, type SentimentPoint } from '../lib/deriveEntryMetrics';

  document.addEventListener('DOMContentLoaded', async () => {
    const container = document.getElementById('deepDiveContainer');
    if (!container) return;

    const jsonUrl = container.getAttribute('data-json');
    const spotsUrl = container.getAttribute('data-spots');
    
    if (!jsonUrl || !spotsUrl) {
      container.innerHTML = '<div class="error-state">Configuration error: missing data URL</div>';
      return;
    }

    try {
      // Fetch both entries and spot prices
      const [entriesResponse, spotsResponse] = await Promise.all([
        fetch(jsonUrl),
        fetch(spotsUrl)
      ]);

      if (!entriesResponse.ok || !spotsResponse.ok) {
        throw new Error('Failed to load data');
      }

      const entriesData = await entriesResponse.json();
      const spotsData = await spotsResponse.json();
      
      const entries = entriesData.entries || [];
      const spots = spotsData.spots || [];

      if (entries.length === 0) {
        container.innerHTML = '<div class="error-state">No entries available</div>';
        return;
      }

      // Build spot prices lookup by symbol
      const spotPricesMap = new Map<string, any[]>();
      spots.forEach((spot: any) => {
        if (spot.symbol && spot.spot_prices) {
          spotPricesMap.set(spot.symbol, spot.spot_prices);
        }
      });

      // Select one random entry
      const randomIndex = Math.floor(Math.random() * entries.length);
      const entry = entries[randomIndex];
      const spotPrices = spotPricesMap.get(entry.symbol) || [];

      // Render the deep dive
      renderDeepDive(container, entry, spotPrices);
    } catch (error) {
      console.error('Deep dive error:', error);
      container.innerHTML = '<div class="error-state">Failed to load sample entry</div>';
    }
  });

  function renderDeepDive(container: HTMLElement, entry: any, spotPrices: any[]) {
    const metrics = calculateMetrics(entry, spotPrices);
    const pricePath = extractPricePath(entry, spotPrices);
    const sentimentPath = extractSentimentPath(entry);

    // Context badges
    const badges: string[] = [];
    
    // Monitoring window length
    if (entry.meta?.duration_sec) {
      const minutes = Math.round(entry.meta.duration_sec / 60);
      badges.push(`<div class="context-badge"><strong>Duration:</strong> ${minutes} min</div>`);
    }
    
    // is_silent - from twitter_sentiment_windows.last_cycle.sentiment_activity.is_silent
    const sentimentActivity = entry.twitter_sentiment_windows?.last_cycle?.sentiment_activity;
    if (sentimentActivity?.is_silent !== undefined) {
      badges.push(`<div class="context-badge"><strong>is_silent:</strong> ${sentimentActivity.is_silent}</div>`);
    }
    
    // Median spread
    if (metrics.medianSpread !== null) {
      badges.push(`<div class="context-badge"><strong>Spread:</strong> ${metrics.medianSpread.toFixed(2)} bps</div>`);
    }
    
    // Liquidity percentile
    if (entry.derived?.liq_global_pct !== undefined) {
      badges.push(`<div class="context-badge"><strong>Liq Global:</strong> ${entry.derived.liq_global_pct.toFixed(1)}%</div>`);
    }
    
    // futures_data_ok flag
    if (entry.flags?.futures_data_ok !== undefined) {
      badges.push(`<div class="context-badge"><strong>futures_ok:</strong> ${entry.flags.futures_data_ok}</div>`);
    }

    const badgesHTML = badges.length > 0 ? `
      <div class="context-badges">
        ${badges.join('')}
      </div>
    ` : '';

    // Metrics table rows
    const metricsRows = [
      ['Start price', metrics.startPrice !== null ? `$${formatMetric(metrics.startPrice, 2)}` : 'N/A'],
      ['End price', metrics.endPrice !== null ? `$${formatMetric(metrics.endPrice, 2)}` : 'N/A'],
      ['Absolute return (%)', formatMetric(metrics.absoluteReturn, 2)],
      ['Log return', formatMetric(metrics.logReturn, 4)],
      ['Maximum favorable excursion (MFE, %)', formatMetric(metrics.mfe, 2)],
      ['Maximum adverse excursion (MAE, %)', formatMetric(metrics.mae, 2)],
      ['Peak-to-trough drawdown (%)', formatMetric(metrics.drawdown, 2)],
      ['Realized volatility (session)', formatMetric(metrics.volatility, 4)],
      ['Median spread (bps)', formatMetric(metrics.medianSpread, 2)],
      ['Mean sentiment (hybrid, session)', formatMetric(metrics.meanSentiment, 4)]
    ];

    container.innerHTML = `
      <div class="deep-dive-content">
        ${badgesHTML}
        
        <div class="chart-container">
          <h3 class="chart-title">Price Path</h3>
          <canvas id="priceChart" class="chart-canvas"></canvas>
        </div>
        
        <div class="chart-container">
          <h3 class="chart-title">Sentiment Over Time</h3>
          <canvas id="sentimentChart" class="chart-canvas"></canvas>
          <p class="chart-caption">Sentiment shown as aggregated window scores, not individual posts.</p>
        </div>
        
        <div class="metrics-table-container">
          <h3 class="chart-title">Derived Metrics</h3>
          <table class="metrics-table">
            <thead>
              <tr>
                <th>Metric</th>
                <th>Value</th>
              </tr>
            </thead>
            <tbody>
              ${metricsRows.map(([label, value]) => `
                <tr>
                  <td>${label}</td>
                  <td>${value}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>
      </div>
    `;

    // Render charts
    requestAnimationFrame(() => {
      renderPriceChart(pricePath, entry.symbol);
      renderSentimentChart(sentimentPath);
    });
  }

  function renderPriceChart(pricePath: PricePoint[], symbol: string) {
    const canvas = document.getElementById('priceChart') as HTMLCanvasElement;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Set canvas size
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    if (pricePath.length === 0) {
      ctx.fillStyle = '#888888';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Price series not present in this sample entry.', canvas.width / 2, canvas.height / 2);
      return;
    }

    const padding = 40;
    const width = canvas.width - 2 * padding;
    const height = canvas.height - 2 * padding;

    // Find ranges
    const minTime = Math.min(...pricePath.map(p => p.elapsed_min));
    const maxTime = Math.max(...pricePath.map(p => p.elapsed_min));
    const minPrice = Math.min(...pricePath.map(p => p.price));
    const maxPrice = Math.max(...pricePath.map(p => p.price));

    const priceRange = maxPrice - minPrice || 1; // Avoid division by zero
    const timeRange = maxTime - minTime || 1;

    // Draw axes
    ctx.strokeStyle = '#3a3a3a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, padding + height);
    ctx.lineTo(padding + width, padding + height);
    ctx.stroke();

    // Draw price line
    ctx.strokeStyle = '#00bcd4';
    ctx.lineWidth = 2;
    ctx.beginPath();

    pricePath.forEach((point, i) => {
      const x = padding + ((point.elapsed_min - minTime) / timeRange) * width;
      const y = padding + height - ((point.price - minPrice) / priceRange) * height;

      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });

    ctx.stroke();

    // Labels
    ctx.fillStyle = '#b0b0b0';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Elapsed Time (minutes)', padding + width / 2, canvas.height - 5);
    
    ctx.save();
    ctx.translate(15, padding + height / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Price ($)', 0, 0);
    ctx.restore();

    // Y-axis ticks
    ctx.textAlign = 'right';
    ctx.fillText(minPrice.toFixed(2), padding - 5, padding + height);
    ctx.fillText(maxPrice.toFixed(2), padding - 5, padding + 10);
  }

  function renderSentimentChart(sentimentPath: SentimentPoint[]) {
    const canvas = document.getElementById('sentimentChart') as HTMLCanvasElement;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    if (sentimentPath.length === 0) {
      ctx.fillStyle = '#888888';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Sentiment windows not present in this sample entry.', canvas.width / 2, canvas.height / 2);
      return;
    }

    const padding = 40;
    const width = canvas.width - 2 * padding;
    const height = canvas.height - 2 * padding;

    const minTime = 0;
    const maxTime = Math.max(...sentimentPath.map(p => p.elapsed_min));
    const timeRange = maxTime - minTime || 1; // Avoid division by zero

    // Fixed sentiment range: -1 to +1
    const minSentiment = -1;
    const maxSentiment = 1;
    const sentimentRange = maxSentiment - minSentiment;

    // Draw axes
    ctx.strokeStyle = '#3a3a3a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, padding + height);
    ctx.lineTo(padding + width, padding + height);
    ctx.stroke();

    // Draw zero line
    ctx.strokeStyle = '#555555';
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);
    const zeroY = padding + height - ((0 - minSentiment) / sentimentRange) * height;
    ctx.beginPath();
    ctx.moveTo(padding, zeroY);
    ctx.lineTo(padding + width, zeroY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Draw sentiment points and lines
    const colors = ['#00bcd4', '#00e5ff'];
    sentimentPath.forEach((point, i) => {
      const x = padding + (point.elapsed_min / timeRange) * width;
      const y = padding + height - ((point.mean_score - minSentiment) / sentimentRange) * height;

      ctx.fillStyle = colors[i % colors.length];
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, 2 * Math.PI);
      ctx.fill();

      // Label
      ctx.fillStyle = '#b0b0b0';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(point.window_label, x, y - 10);
    });

    // Labels
    ctx.fillStyle = '#b0b0b0';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Time (minutes)', padding + width / 2, canvas.height - 5);
    
    ctx.save();
    ctx.translate(15, padding + height / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Mean Score (-1 to +1)', 0, 0);
    ctx.restore();

    // Y-axis ticks
    ctx.textAlign = 'right';
    ctx.fillText('-1.0', padding - 5, padding + height);
    ctx.fillText('0.0', padding - 5, zeroY + 5);
    ctx.fillText('+1.0', padding - 5, padding + 10);
  }
</script>
